<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer Documentation · Korg</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Korg logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Korg</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Quickstart</a></li><li><a class="tocitem" href="../install/">Install</a></li><li><a class="tocitem" href="../API/">high-level API</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li class="is-active"><a class="tocitem" href>Developer Documentation</a><ul class="internal"><li><a class="tocitem" href="#Julia-development"><span>Julia development</span></a></li><li><a class="tocitem" href="#Code-guidelines"><span>Code guidelines</span></a></li><li><a class="tocitem" href="#Continuum-absorption"><span>Continuum absorption</span></a></li><li><a class="tocitem" href="#Manifest.toml-and-Project.toml"><span><code>Manifest.toml</code> and <code>Project.toml</code></span></a></li><li><a class="tocitem" href="#Where-to-put-data"><span>Where to put data</span></a></li><li><a class="tocitem" href="#Complete-API"><span>Complete API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ajwheeler/Korg.jl/blob/main/docs/src/devdocs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-documentation"><a class="docs-heading-anchor" href="#Developer-documentation">Developer documentation</a><a id="Developer-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-documentation" title="Permalink"></a></h1><p>This page contains info for people interested in contributing code to Korg.  If you  have questions, do not hesitate to ask.</p><h2 id="Julia-development"><a class="docs-heading-anchor" href="#Julia-development">Julia development</a><a id="Julia-development-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-development" title="Permalink"></a></h2><p>If you&#39;ve never developed a package in Julia, here are some tips.</p><ul><li>Once you have a local copy of Korg, you can make it importable locally by <code>dev</code>ing it from the Julia environment in which you would like to run it: <code>Pkg.dev(&quot;/path/to/Korg&quot;)</code>.  If you run <code>Pkg.dev(&quot;Korg&quot;)</code> instead, Julia will automatically clone the repo to <code>~/.julia/dev/Korg</code>.  (See the <a href="https://pkgdocs.julialang.org/">Pkg documentation</a> for details.)</li><li>When working on your local copy of Korg, <a href="https://github.com/timholy/Revise.jl">Revise</a> is easiest way to make and test changes without constantly restarting your Julia session.</li><li>To run the test suite locally, start a Julia session in the Korg root directory and run <code>]activate .</code> then <code>test</code>.  This will automatically run <code>test/runtests.jl</code> in the test environment.</li><li>Documentation is generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documentor</a>. Continuous integration on github will ensure that the documentation is generated without errors, but it won&#39;t catch all formatting problems.  If you wish to generate documentation locally in order to check that everything is as expected, start a Julia session in <code>Korg/docs</code>, activate the test environment (<code>]activate .</code>), and run <code>instantiate</code>.  This downloads and installs the docs dependences, and will only have to be run once.  To generate documentation, run <code>julia --project make.jl</code> on the command line (the <code>--project</code> flag activates the local environment).  The generated docs can be served from <code>docs/build</code>.</li></ul><h2 id="Code-guidelines"><a class="docs-heading-anchor" href="#Code-guidelines">Code guidelines</a><a id="Code-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Code-guidelines" title="Permalink"></a></h2><ul><li>Try to be explicit about units throughout the code, particularly when not using CGS.</li><li>Whenever possible, calculations should be precise up to a factor of <span>$10^{-3}$</span>.  When it&#39;s easy and inexpensive, they should be precise to <span>$10^{-5}$</span> or better.  There are exceptions to this (e.g. the Voigt function), but ideally they will eventually be vanquished.</li><li>Ensure types are generic enough to support dual numbers and autodifferentiation. </li><li>Limit lines to 100 characters.</li><li>Use ASCII characters in the names of functions that are part of the public API.</li><li>Unless they will never be called elsewhere, provide docstrings describing the inputs, assumptions and outputs of any functions you write.</li></ul><h2 id="Continuum-absorption"><a class="docs-heading-anchor" href="#Continuum-absorption">Continuum absorption</a><a id="Continuum-absorption-1"></a><a class="docs-heading-anchor-permalink" href="#Continuum-absorption" title="Permalink"></a></h2><p>Steps for implementing new continuum sources of absorption:</p><ul><li>Define a helper function that computes a single absorption coefficient (in units of cm⁻²). The function should accept <code>ν</code> (in Hz) and <code>T</code> (in K) as the first and second arguments, respectively. The convention is for it should share a name with the corresponding public function, but have an underscore pre-appended (e.g. we define <code>_H_I_bf</code> to help implement <code>H_I_bf</code>).</li><li>The public function is the function constructed and returned by <code>Korg.ContinuumAbsorption.bounds_checked_absorption</code> that wraps the above helper function. This wrapper function implements bounds-checking for <code>ν</code> and <code>T</code> and supports the keyword arguments described in <a href="../API/#Continuum-Absorption-Kwargs">Continuum Absorption Kwargs</a>.</li><li>Add a docstring describing the new function. At the very least, please describe any non-standard arguments and include a reference in the docstring to the source where the function was taken from.</li><li>Add a line to <code>doc/src/API.md</code> under the <code>Continuum absorption</code> heading to render the docstring of your new function.</li><li>Add a line to <code>total_continuum_absorption</code> that calls the new public function for absorption.</li></ul><p>The first two steps may not apply for sources that don&#39;t directly depend on <code>ν</code> and <code>T</code> (e.g. absorption from scattering).</p><h2 id="Manifest.toml-and-Project.toml"><a class="docs-heading-anchor" href="#Manifest.toml-and-Project.toml"><code>Manifest.toml</code> and <code>Project.toml</code></a><a id="Manifest.toml-and-Project.toml-1"></a><a class="docs-heading-anchor-permalink" href="#Manifest.toml-and-Project.toml" title="Permalink"></a></h2><p><a href="https://pkgdocs.julialang.org/v1/toml-files/">Read more about these files here.</a> These files are used by the julia package manager.  <code>Project.toml</code> records dependencies, and you&#39;ll  notice that the test and docs directories have their own <code>Project.toml</code>s for test and  documentation-specific dependencies.  <code>Manifest.toml</code> records exact package versions used when a  package was run.  It enables someone else to reproduce the exact environment and results later.   There are a few directories containing scripts that generate Korg&#39;s data files which have there own  <code>Projects.toml</code>s and <code>Manifest.toml</code>s, for example <code>data/bf_cross-sections/</code>.</p><h2 id="Where-to-put-data"><a class="docs-heading-anchor" href="#Where-to-put-data">Where to put data</a><a id="Where-to-put-data-1"></a><a class="docs-heading-anchor-permalink" href="#Where-to-put-data" title="Permalink"></a></h2><p>If you are adding data to Korg, <code>data/README</code> provides an overview of the options and how to decide  between them.</p><h2 id="Complete-API"><a class="docs-heading-anchor" href="#Complete-API">Complete API</a><a id="Complete-API-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-API" title="Permalink"></a></h2><p>Here are all the documented methods in Korg.</p><article class="docstring"><header><a class="docstring-binding" id="Korg.Formula" href="#Korg.Formula"><code>Korg.Formula</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents an atom or molecule, irespective of its charge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.Line-Union{Tuple{F}, Tuple{F, F, Korg.Species, F}, Tuple{F, F, Korg.Species, F, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}, Union{Missing, Tuple{F, F}, F}}} where F&lt;:Real" href="#Korg.Line-Union{Tuple{F}, Tuple{F, F, Korg.Species, F}, Tuple{F, F, Korg.Species, F, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}, Union{Missing, Tuple{F, F}, F}}} where F&lt;:Real"><code>Korg.Line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Line(wl::F, log_gf::F, species::Species, E_lower::F, 
     gamma_rad::Union{F, Missing}=missing, gamma_stark::Union{F, Missing}=missing, 
     vdw::Union{F, Tuple{F, F}, Missing}, missing) where F &lt;: Real</code></pre><p>Arguments:</p><ul><li><code>wl</code>: wavelength, in cm</li><li><code>log_gf</code>: (log base 10) oscillator strength (unitless)</li><li><code>species</code>: the <code>Species</code> associated with the line</li><li><code>E_lower</code>: The energy (excitiation potential) of the lower energy level (eV)</li></ul><p>Optional Arguments (these override default recipes):</p><ul><li><code>gamma_rad</code>: Fundemental width</li><li><code>gamma_stark</code>: Stark broadening width at 10,000 K (s⁻¹)</li><li><code>vdW</code>: If this is present, it may may be log(Γ_vdW) (assumed if negative) or the   <a href="https://www.astro.uu.se/~barklem/howto.html">ABO parameters</a> as packed float or a   <code>Tuple</code>, <code>(σ, α)</code>.</li></ul><p>Note the the &quot;gamma&quot; values here are FWHM, not HWHM, of the Lorenztian component of the line  profile, and are in units of s⁻¹.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/linelist.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.PlanarAtmosphere-Tuple{Korg.ShellAtmosphere}" href="#Korg.PlanarAtmosphere-Tuple{Korg.ShellAtmosphere}"><code>Korg.PlanarAtmosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PlanarAtmosphere(atm::ShellAtmosphere)</code></pre><p>Construct a planar atmosphere with the data from a shell atmosphere.  Mostly useful for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ShellAtmosphere-Tuple{Korg.PlanarAtmosphere, Any}" href="#Korg.ShellAtmosphere-Tuple{Korg.PlanarAtmosphere, Any}"><code>Korg.ShellAtmosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShellAtmosphere(atm::PlanarAtmosphere, R)</code></pre><p>Construct a shell atmosphere with the data from a planar atmosphere and an outer radius.  Mostly  useful for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.Species" href="#Korg.Species"><code>Korg.Species</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents an atom or molecule (a <code>Formula</code>) with a particular number of electrons (regardless of  their configuration).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L140-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.Species-Tuple{AbstractString}" href="#Korg.Species-Tuple{AbstractString}"><code>Korg.Species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Species(code::AbstractString)</code></pre><p>Parse the &quot;species code&quot; in many of the forms in which it is often specifieds and return an object  representing the sepcies.</p><p><strong>Examples</strong></p><ul><li>&quot;H I&quot; -&gt; H I</li><li>&quot;H 1&quot; -&gt; H I</li><li>&quot;H     1&quot; -&gt; H I</li><li>&quot;H_1&quot; -&gt; H I</li><li>&quot;H.I&quot; -&gt; H I</li><li>&quot;H 2&quot; -&gt; H II</li><li>&quot;H2&quot; -&gt; H₂</li><li>&quot;H&quot; -&gt; H I</li><li>&quot;01.00&quot; → H I</li><li>&quot;02.01&quot; → He II</li><li>&quot;02.1000&quot; → He II</li><li>&quot;0608&quot; → CO I</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To parse at compile time, use the <code>species</code> string macro, i.e. <code>species&quot;H I&quot;</code>.  This is  important in hot inner loops.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L156-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg._get_multi_X_H-Tuple{Any, Any, Any}" href="#Korg._get_multi_X_H-Tuple{Any, Any, Any}"><code>Korg._get_multi_X_H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of abundances, <code>A_X</code>, get [I+J+K/H], where <code>Zs = [I,J,K]</code> is a vector of atomic  numbers.  This is used to calculate, for example, [α/H] and [metals/H].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/synthesize.jl#L332-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg._korg_data_dir-Tuple{}" href="#Korg._korg_data_dir-Tuple{}"><code>Korg._korg_data_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the local where Korg&#39;s large (too big for git) data files are stored.  At present, this is only the model atmosphere archive used by <a href="../API/#Korg.interpolate_marcs"><code>interpolate_marcs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L161-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.air_to_vacuum-Tuple{Any}" href="#Korg.air_to_vacuum-Tuple{Any}"><code>Korg.air_to_vacuum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">air_to_vacuum(λ; cgs=λ&lt;1)</code></pre><p>Convert λ from an air to vacuum.  λ is assumed to be in Å if it is ⩾ 1, in cm otherwise.  Formula  from Birch and Downs (1994) via the VALD website.</p><p>See also: <a href="../API/#Korg.vacuum_to_air"><code>vacuum_to_air</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L130-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.all_atomic_species-Tuple{}" href="#Korg.all_atomic_species-Tuple{}"><code>Korg.all_atomic_species</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_atomic_species()</code></pre><p>Returns an iterator that runs over all atomic species supported by Korg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.approximate_gammas-Tuple{Any, Any, Any}" href="#Korg.approximate_gammas-Tuple{Any, Any, Any}"><code>Korg.approximate_gammas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approximate_gammas(wl, species, E_lower; ionization_energies=Korg.ionization_energies)</code></pre><p>A simplified form of the Unsoeld (1955) approximation for van der Waals broadening and the  <a href="https://ui.adsabs.harvard.edu/abs/1971Obs....91..139C/abstract">Cowley 1971</a> approximation for  Stark broadening, evaluated at 10,000 K.  Used for atomic lines with no vdW and stark broadening info in the linelist.</p><p>Returns <code>(γ_stark</code>, <code>log10(γ_vdW))</code> in Hz, where these are the per-perturber quantities. For autoionizing lines (those for which E<em>upper &gt; χ), Returns 0.0 for γ</em>vdW. Note the the &quot;gamma&quot;  values here are FWHM, not HWHM, of the Lorenztian component of the line profile. </p><p>In the calculation of <code>n*²</code>, uses the approximation that <span>$\overbar{r^2} = 5/2 {n^*}^4 / Z^2$</span> which neglects the dependence on the angular momentum quantum number, l, in the the form given by <a href="https://ui.adsabs.harvard.edu/abs/1967MNRAS.136..381W/abstract">Warner 1967</a> (the earliest english  work reporting the Unsoeld result).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/linelist.jl#L81-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.approximate_radiative_gamma-Tuple{Any, Any}" href="#Korg.approximate_radiative_gamma-Tuple{Any, Any}"><code>Korg.approximate_radiative_gamma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approximate_radiative_gamma(wl, log_gf)</code></pre><p>Approximate radiate broadening parameter.  When using this, make sure that <code>log_gf</code> is the true  value (not adjusted for isotopic abundance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/linelist.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.blackbody-Tuple{Any, Any}" href="#Korg.blackbody-Tuple{Any, Any}"><code>Korg.blackbody</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blackbody(T, λ)</code></pre><p>The value of the Planck blackbody function for temperature <code>T</code> at wavelength <code>λ</code> [cm].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/synthesize.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.chemical_equilibrium-NTuple{7, Any}" href="#Korg.chemical_equilibrium-NTuple{7, Any}"><code>Korg.chemical_equilibrium</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chemical_equilibrium(T, nₜ, nₑ, absolute_abundances, ionization_energies, 
                     partition_fns, log_equilibrium_constants; x0=nothing)</code></pre><p>Iteratively solve for the number density of each species. Returns a <code>Dict</code> mapping species to number  densities.</p><p>arguments:</p><ul><li>the temperature, <code>T</code>, in K</li><li>the number density of non-electron particles <code>nₜ</code></li><li>the electron number density <code>nₑ</code></li><li>A Dict of <code>absolute_abundances</code>, N<em>X/N</em>total</li><li>a Dict of ionization energies, <code>ionization_energies</code>.  The keys of act as a list of all atoms.</li><li>a Dict of partition functions, <code>partition_fns</code></li><li>a Dict of log molecular equilibrium constants, <code>log_equilibrium_constants</code>, in partial pressure form.  The keys of <code>equilibrium_constants</code> act as a list of all molecules.</li></ul><p>keyword arguments:</p><ul><li><code>x0</code> (default: <code>nothing</code>) is an initial guess for the solution (in the format internal to  <code>chemical_equilibrium</code>). If not supplied, a good guess is computed by neglecting molecules.</li><li><code>electron_number_density_warn_threshold</code> (default: <code>0.25</code>) is the fractional difference between  the calculated electron number density and the model atmosphere electron number density at which  a warning is issued.</li></ul><p>The system of equations is specified with the number densities of the neutral atoms as free  parameters.  Each equation specifies the conservation of a particular species, e.g. (simplified)</p><pre><code class="nohighlight hljs">n(O) = n(CO) + n(OH) + n(O I) + n(O II) + n(O III).</code></pre><p>In this equation:</p><ul><li><code>n(O)</code>, the number density of oxygen atoms in any form comes <code>absolute_abundances</code> and the total</li></ul><p>number density (supplied later)</p><ul><li><code>n(O I)</code> is a free parameter.  The numerical solver is varying this to satisfy the system of  equations.</li><li><code>n(O II)</code>, and <code>n(O III)</code> come from the Saha (ionization) equation given <code>n(O I)</code></li><li><code>n(CO)</code> and <code>n(OH)</code> come from the molecular equilibrium constants K, which are precomputed  over a range of temperatures. </li></ul><p>Equilibrium constants are defined in terms of partial pressures, so e.g.</p><pre><code class="nohighlight hljs">K(OH)  ==  (p(O) p(H)) / p(OH)  ==  (n(O) n(H)) / n(OH)) kT</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/statmech.jl#L63-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.constant_R_LSF-Union{Tuple{F}, Tuple{AbstractVector{F}, Any, Any}} where F&lt;:Real" href="#Korg.constant_R_LSF-Union{Tuple{F}, Tuple{AbstractVector{F}, Any, Any}} where F&lt;:Real"><code>Korg.constant_R_LSF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constant_R_LSF(flux, wls, R; window_size=3)</code></pre><p>Applies a gaussian line spread function the the spectrum with flux vector <code>flux</code> and wavelength vector <code>wls</code> with constant spectral resolution, <span>$R = \lambda/\Delta\lambda$</span>, where  <span>$\Delta\lambda$</span> is the LSF FWHM.  The <code>window_size</code> argument specifies how far out to extend the convolution kernel in standard deviations.</p><p>For the best match to data, your wavelength range should extend a couple <span>$\Delta\lambda$</span> outside  the region you are going to compare.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><ul><li><p>This is a naive, slow implementation.  Do not use it when performance matters.</p></li><li><p><code>constant_R_LSF</code> will have weird behavior if your wavelength grid is not locally linearly-spaced.  It is intended to be run on a fine wavelength grid, then downsampled to the observational (or   otherwise desired) grid.</p></li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L58-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.contained-Tuple{Real, Korg.Interval}" href="#Korg.contained-Tuple{Real, Korg.Interval}"><code>Korg.contained</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contained(value, interval)</code></pre><p>Returns whether <code>value</code> is contained by <code>interval</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; contained(0.5, Interval(1.0,10.0))
false
julia&gt; contained(5.0, Interval(1.0,10.0))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L191-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.contained_slice-Tuple{AbstractVector, Korg.Interval}" href="#Korg.contained_slice-Tuple{AbstractVector, Korg.Interval}"><code>Korg.contained_slice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contained_slice(vals, interval)</code></pre><p>Returns a range of indices denoting the elements of <code>vals</code> (which are assumed to be sorted in  increasing order) that are contained by <code>interval</code>. When no entries are contained by interval, this returns <code>(1,0)</code> (which is a valid empty slice).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L207-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.doppler_width-NTuple{4, Any}" href="#Korg.doppler_width-NTuple{4, Any}"><code>Korg.doppler_width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">doppler_width(λ₀ T, m, ξ)</code></pre><p>The standard deviation of of the doppler-broadening profile.  In standard spectroscopy texts, the  Doppler width often refers to σ√2, but this is σ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L254-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.download_atmosphere_archive" href="#Korg.download_atmosphere_archive"><code>Korg.download_atmosphere_archive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_atmosphere_archive()</code></pre><p>Download the data used by <a href="../API/#Korg.interpolate_marcs"><code>interpolate_marcs</code></a>, a repacked version of the  <a href="https://dr17.sdss.org/sas/dr17/apogee/spectro/speclib/atmos/marcs/MARCS_v3_2016/Readme_MARCS_v3_2016.txt">MARCS SDSS grid</a>. By default, the archive is stored at <code>.korg/SDSS_MARCS_atmospheres.h5</code>.  This location can be set  with the <code>KORG_DATA_DIR</code> environment variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L204-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.format_A_X-Union{Tuple{}, Tuple{Real}, Tuple{V}, Tuple{K}, Tuple{Real, Real}, Tuple{Real, Real, Dict{K, V}}} where {K, V}" href="#Korg.format_A_X-Union{Tuple{}, Tuple{Real}, Tuple{V}, Tuple{K}, Tuple{Real, Real}, Tuple{Real, Real, Dict{K, V}}} where {K, V}"><code>Korg.format_A_X</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">format_A_X(default_metals_H, default_alpha_H, abundances; kwargs... )</code></pre><p>Returns a 92 element vector containing abundances in <span>$A(X)$</span> (<span>$\log_{10}(X/H) + 12$</span>) format for elements from hydrogen to uranium.</p><p><strong>Arguments</strong></p><p>You can specify abundance with these positional arguments.  All are optional, but if  <code>default_alpha_H</code> is provided, <code>default_metals_H</code> must be as well. </p><ul><li><code>default_metals_H</code> (default: 0), i.e. [metals/H] is the <span>$\log_{10}$</span> solar-relative abundance of elements heavier   than He. It is overriden by <code>default_alpha</code> and <code>abundances</code> on a per-element basis.  </li><li><code>default_alpha_H</code> (default: same as <code>default_metals_H</code>), i.e. [alpha/H] is the <span>$\log_{10}$</span>   solar-relative abundance of the alpha elements (defined to be C, O, Ne, Mg, Si, S, Ar, Ca, and   Ti). It is overriden by <code>abundances</code> on a per-element basis.</li><li><code>abundances</code> is a <code>Dict</code> mapping atomic numbers or symbols to [<span>$X$</span>/H] abundances.  (Set  <code>solar_relative=false</code> to use <span>$A(X)$</span> abundances instead.) These override <code>default_metals_H</code>. This is the only way to specify an abundance of He that is non-solar.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>solar_relative</code> (default: true): When true, interpret abundances as being in [<span>$X$</span>/H]  (<span>$\log_{10}$</span> solar-relative) format.  When false, interpret them as <span>$A(X)$</span> abundances, i.e.   <span>$A(x) = \log_{10}(n_X/n_\mathrm{H}) + 12$</span>, where <span>$n_X$</span> is the number density of <span>$X$</span>.  Note that abundances not specified default to the solar value still depend on the solar value, as  they are set according to <code>default_metals_H</code> and <code>default_alpha_H</code>.</li><li><code>solar_abundances</code> (default: <code>Korg.asplund_2020_solar_abundances</code>) is the set of solar abundances to  use, as a vector indexed by atomic number. <code>Korg.asplund_2009_solar_abundances</code> and  <code>Korg.grevesse_2007_solar_abundances</code> are also provided for convienience.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/synthesize.jl#L224-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_alpha_H-Tuple{Any}" href="#Korg.get_alpha_H-Tuple{Any}"><code>Korg.get_alpha_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_alpha_H(A_X)</code></pre><p>Calculate [α/H] given a vector, <code>A_X</code> of absolute abundances, <span>$A(X) = \log_{10}(n_α/n_\mathrm{H})$</span>. Here, the alpha elements are defined to be O, Ne, Mg, Si, S, Ar, Ca, Ti.  See also  <a href="#Korg.get_alpha_H-Tuple{Any}"><code>get_alpha_H</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/synthesize.jl#L321-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_atmosphere_archive-Tuple{}" href="#Korg.get_atmosphere_archive-Tuple{}"><code>Korg.get_atmosphere_archive</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the model atmosphere grid, first loading it into memory if necessary. It&#39;s not loaded  at import time because it&#39;s large, and model atmosphere interpolation isn&#39;t always needed. This is called automatically when running <code>interpolate_marcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_atoms-Tuple{Korg.Formula}" href="#Korg.get_atoms-Tuple{Korg.Formula}"><code>Korg.get_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_atoms(x)</code></pre><p>Returns an array view containing the atomic number of each atom that makes up the formula or species  x.  E.g. <code>get_atoms(Korg.species&quot;H2O&quot;)</code> yields [1, 1, 8].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_electron_number_densities-Tuple{Korg.ModelAtmosphere}" href="#Korg.get_electron_number_densities-Tuple{Korg.ModelAtmosphere}"><code>Korg.get_electron_number_densities</code></a> — <span class="docstring-category">Method</span></header><section><div><p>electron<em>number</em>densities(atm::ModelAtmosphere) = [l.electron<em>number</em>density for l in atm.layers]</p><p>This is a convienince functions for making plots, etc.  Note that it doesn&#39;t access quantities in a  memory-efficient order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_log_nK-Tuple{Any, Any, Any}" href="#Korg.get_log_nK-Tuple{Any, Any, Any}"><code>Korg.get_log_nK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_inv_nK(mol, T, log_equilibrium_constants)</code></pre><p>Given a molecule, <code>mol</code>, a temperature, <code>T</code>, and a dictionary of log equilbrium constants in partial pressure form, return the inverse equilibrium constant in number density form, i.e. <code>1/nK</code> where  <code>nK = n(A)n(B)/n(AB)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/statmech.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_mass-Tuple{Korg.Formula}" href="#Korg.get_mass-Tuple{Korg.Formula}"><code>Korg.get_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mass(f::Formula)</code></pre><p>Returns the mass [g] of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_metals_H-Tuple{Any}" href="#Korg.get_metals_H-Tuple{Any}"><code>Korg.get_metals_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_metals_H(A_X)</code></pre><p>Calculate [metals/H] given a vector, <code>A_X</code> of absolute abundances, <span>$A(X) = \log_{10}(n_M/n_\mathrm{H})$</span>. See also <a href="#Korg.get_alpha_H-Tuple{Any}"><code>get_alpha_H</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/synthesize.jl#L311-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_number_densities-Tuple{Korg.ModelAtmosphere}" href="#Korg.get_number_densities-Tuple{Korg.ModelAtmosphere}"><code>Korg.get_number_densities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_densities(atm::ModelAtmosphere) = [l.number_density for l in atm.layers]</code></pre><p>This is a convienince functions for making plots, etc.  Note that it doesn&#39;t access quantities in a  memory-efficient order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_tau_5000s-Tuple{Korg.ModelAtmosphere}" href="#Korg.get_tau_5000s-Tuple{Korg.ModelAtmosphere}"><code>Korg.get_tau_5000s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tau_5000s(atm::ModelAtmosphere) = [l.tau_5000 for l in atm.layers]</code></pre><p>This is a convienince functions for making plots, etc.  Note that it doesn&#39;t access quantities in a  memory-efficient order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_temps-Tuple{Korg.ModelAtmosphere}" href="#Korg.get_temps-Tuple{Korg.ModelAtmosphere}"><code>Korg.get_temps</code></a> — <span class="docstring-category">Method</span></header><section><div><p>temps(atm::ModelAtmosphere) = [l.temp for l in atm.layers]</p><p>This is a convienince functions for making plots, etc.  Note that it doesn&#39;t access quantities in a  memory-efficient order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.get_zs-Tuple{Korg.ModelAtmosphere}" href="#Korg.get_zs-Tuple{Korg.ModelAtmosphere}"><code>Korg.get_zs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>zs(atm::ModelAtmosphere) = [l.z for l in atm.layers]</p><p>This is a convienince functions for making plots, etc.  Note that it doesn&#39;t access quantities in a  memory-efficient order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.hummer_mihalas_U_H-NTuple{4, Any}" href="#Korg.hummer_mihalas_U_H-NTuple{4, Any}"><code>Korg.hummer_mihalas_U_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hummer_mihalas_U_H(T, nH, nHe, ne)</code></pre><p>!!!note     This is experimental, and not used by Korg for spectral synthesis.</p><p>Calculate the partition function of neutral hydrogen using the occupation probability formalism from Hummer and Mihalas 1988.  See <a href="#Korg.hummer_mihalas_w-NTuple{5, Any}"><code>hummer_mihalas_w</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/statmech.jl#L369-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.hummer_mihalas_w-NTuple{5, Any}" href="#Korg.hummer_mihalas_w-NTuple{5, Any}"><code>Korg.hummer_mihalas_w</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hummer_mihalas_w(T, n, E_level, nH, nHe, ne)</code></pre><p>Calculate the corection, w, to the occupation fraction of a hydrogen energy level using the  occupation probability formalism from Hummer and Mihalas 1988, optionally with the generalization by  Hubeny+ 1994.  (Sometimes Daepen+ 1987 is cited instead, but H&amp;M seems to be where the theory  originated. Presumably it was delayed in publication.)</p><p>The expression for w is in equation 4.71 of H&amp;M.  K, the QM correction used in defined in equation 4.24. Note that H&amp;M&#39;s &quot;N&quot;s are numbers (not number densities), and their &quot;V&quot; is volume.  These quantities  apear only in the form N/V, so we use the number densities instead.</p><p>This is based partially on Paul Barklem and Kjell Eriksson&#39;s  <a href="https://github.com/barklem/hlinop/blob/master/hbop.f">WCALC fortran routine</a>  (part of HBOP.f), which is used by (at least) Turbospectrum and SME.  As in that routine, we do  consider hydrogen and helium as the relevant neutral species, and assume them to be in the ground  state.  All ions are assumed to have charge 1.  Unlike that routine, the generalization to the  formalism from Hubeny+ 1994 is turned off by default because I haven&#39;t closely checked it.  The  difference effects the charged<em>term only, and temerature is only used when  `use</em>hubeny_generalization<code>is set to</code>true`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/statmech.jl#L280-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.hydrogen_line_absorption!-NTuple{9, Any}" href="#Korg.hydrogen_line_absorption!-NTuple{9, Any}"><code>Korg.hydrogen_line_absorption!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydrogen_line_absorption!(αs, λs, T, nₑ, nH_I, UH_I, ξ, window_size; kwargs...)</code></pre><p>Calculate contribution to the the absorption coefficient, αs, from hydrogen lines in units of cm^-1, at wavelengths <code>λs</code> (a vector of ranges).</p><p>Uses profiles from <a href="https://ui.adsabs.harvard.edu/abs/1999A%26AS..140...93S/abstract">Stehlé &amp; Hutcheon (1999)</a>, which include Stark and Doppler broadening.   For Halpha, Hbeta, and Hgamma, the p-d approximated profiles from  <a href="https://ui.adsabs.harvard.edu/abs/2000A%26A...363.1091B/abstract">Barklem, Piskunovet, and O&#39;Mara 2000</a> are added to the absortion coefficient.  This &quot;convolution by summation&quot; is inexact, but true  convolution is expensive.</p><p>Arguments:</p><ul><li><code>T</code>: temperature [K]</li><li><code>nₑ</code>: electron number density [cm^-3]</li><li><code>nH_I</code>: neutral hydrogen number density [cm^-3]</li><li><code>UH_I</code>: the value of the neutral hydrogen partition function</li><li><code>ξ</code>: microturbulent velocity [cm/s]. This is only applied to Hα-Hγ.  Other hydrogen lines profiles   are dominated by stark broadening, and the stark broadened profiles are pre-convolved with a   doppler profile.</li><li><code>window_size</code>: the max distance from each line center [cm] at which to calculate the stark  and self broadening profiles  absorption for Hα-Hγ (those dominated by self-broadening).</li></ul><p>Keyword arguments:</p><ul><li><code>stark_profiles</code> (default: <code>Korg._hline_stark_profiles</code>): tables from which to interpolate Stark   profiles</li><li><code>use_MHD</code>: whether or not to use the Mihalas-Daeppen-Hummer formalism to adjust the occupation   probabilities of each hydrogen orbital for plasma effects.  Default: <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L152-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.interpolate_marcs-Tuple{Any, Any, Vector}" href="#Korg.interpolate_marcs-Tuple{Any, Any, Vector}"><code>Korg.interpolate_marcs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_marcs(Teff, logg, Fe_M=0, alpha_M=0, C_M=0; kwargs...)
interpolate_marcs(Teff, logg, A_X; kwargs...)</code></pre><p>Returns a model atmosphere obtained by interpolating the MARCS SDSS atmosphere grid, which provides  atmospheres for varying values of <span>$T_\mathrm{eff}$</span>, `<code>\log g</code>, [metals/H], [alpha/metals],  and [C/metals].  If the <code>A_X</code> (a vector of abundances in the format returned by <a href="../API/#Korg.format_A_X"><code>format_A_X</code></a> and accepted by <a href="../API/#Korg.synthesize"><code>synthesize</code></a>) is provided instead of <code>M_H</code>, <code>alpha_M</code>, and <code>C_M</code>, the  solar-relative ratios will be reconstructed assuming Grevesse+ 2007 solar abundances.</p><p>The model atmosphere grid is a repacked version of the  <a href="https://dr17.sdss.org/sas/dr17/apogee/spectro/speclib/atmos/marcs/MARCS_v3_2016/Readme_MARCS_v3_2016.txt">MARCS SDSS grid</a>. Before you use <code>interpolate_marcs</code> for the first time, you will have to download the grid with by  running <code>download_atmosphere_archive()</code>.  By default, the archive is stored at  <code>.korg/SDSS_MARCS_atmospheres.h5</code>.  This location can be set with the <code>KORG_DATA_DIR</code> environment  variable.</p><p><strong>keyword arguments</strong></p><ul><li><code>spherical</code>: whether or not to return a ShellAtmosphere (as opposed to a PlanarAtmosphere).  By  default true when <code>logg</code> &lt; 3.5.</li><li><code>archive</code>: The atmosphere archive to use.  This is used to override the default grid for testing.</li><li><code>solar_abundances</code>: (default: <code>grevesse_2007_solar_abundances</code>) The solar abundances to use when  <code>A_X</code> is provided instead of <code>M_H</code>, <code>alpha_M</code>, and <code>C_M</code>. The default is chosen to match that of  the atmosphere grid, and is probably no good reason to change it.</li><li><code>clamp_abundances</code>: (default: <code>false</code>) allowed when specifying <code>A_X</code> direction. Whether or not to   clamp the abundance paramerters to be within the range of the MARCS grid to avoid throwing an out   of bounds error. Use with caution.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Atmosphere interpolation contributes non-negligeble error to synthesized spectra below  Teff ≈ 4250 K. We do not endorse using it for science in that regime. See  https://github.com/ajwheeler/Korg.jl/issues/164 for a discussion of the issue.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L244-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.inverse_gaussian_density-Tuple{Any, Any}" href="#Korg.inverse_gaussian_density-Tuple{Any, Any}"><code>Korg.inverse_gaussian_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_gaussian_density(ρ, σ)</code></pre><p>Calculate the inverse of a (0-centered) Gaussian PDF with standard deviation <code>σ</code>, i.e. the value of  <code>x</code> for which <code>ρ = exp(-0.5 x^2/σ^2}) / √[2π]</code>, which is given by <code>σ √[-2 log (√[2π]σρ)]</code>.  Returns  0 when ρ is larger than any value taken on by the PDF.</p><p>See also: <a href="#Korg.inverse_lorentz_density-Tuple{Any, Any}"><code>inverse_lorentz_density</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.inverse_lorentz_density-Tuple{Any, Any}" href="#Korg.inverse_lorentz_density-Tuple{Any, Any}"><code>Korg.inverse_lorentz_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_lorentz_density(ρ, γ)</code></pre><p>Calculate the inverse of a (0-centered) Lorentz PDF with width <code>γ</code>, i.e. the value of <code>x</code> for which  <code>ρ = 1 / (π γ (1 + x^2/γ^2))</code>, which is given by <code>√[γ/(πρ) - γ^2]</code>. Returns 0 when ρ is larger than  any value taken on by the PDF.</p><p>See also: <a href="#Korg.inverse_gaussian_density-Tuple{Any, Any}"><code>inverse_gaussian_density</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L101-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ismolecule-Tuple{Korg.Formula}" href="#Korg.ismolecule-Tuple{Korg.Formula}"><code>Korg.ismolecule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismolecule(f::Formula)</code></pre><p><code>true</code> when <code>f</code> is composed of more than one atom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.line_absorption!-NTuple{9, Any}" href="#Korg.line_absorption!-NTuple{9, Any}"><code>Korg.line_absorption!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_absorption(linelist, λs, temp, nₑ, n_densities, partition_fns, ξ
               ; α_cntm=nothing, cutoff_threshold=1e-3, window_size=20.0*1e-8)</code></pre><p>Calculate the opacity coefficient, α, in units of cm^-1 from all lines in <code>linelist</code>, at wavelengths <code>λs</code> [cm^-1]. </p><p>other arguments:</p><ul><li><code>temp</code> the temerature in K (as a vector, for multiple layers, if you like)</li><li><code>n_densities</code>, a Dict mapping species to absolute number density in cm^-3 (as a vector, if temp is  a vector).</li><li><code>partition_fns</code>, a Dict containing the partition function of each species</li><li><code>ξ</code> is the microturbulent velocity in cm/s (n.b. NOT km/s)</li><li><code>α_cntm</code> is as a callable returning the continuum opacity as a function of wavelength. The window   within which a line is calculated will extend to the wavelength at which the Lorentz wings or   Doppler core of the line are at <code>cutoff_threshold * α_cntm[line.wl]</code>, whichever is greater.  </li><li><code>cuttoff_threshold</code> (optional, default: 1e-3): see <code>α_cntm</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.line_profile-NTuple{5, Real}" href="#Korg.line_profile-NTuple{5, Real}"><code>Korg.line_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_profile(λ₀, σ, γ, amplitude, λ)</code></pre><p>A voigt profile centered on λ₀ with Doppler width σ (NOT √[2] σ, as the &quot;Doppler width&quot; is often  defined) and Lorentz HWHM γ evaluated at <code>λ</code> (cm).  Returns values in units of cm^-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L303-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.load_atomic_partition_functions" href="#Korg.load_atomic_partition_functions"><code>Korg.load_atomic_partition_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_atomic_partition_functions()</code></pre><p>Loads saved tabulated values for atomic partition functions from disk. Returns a dictionary mapping species to interpolators over log(T).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/read_statmech_quantities.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.load_exomol_partition_functions-Tuple{}" href="#Korg.load_exomol_partition_functions-Tuple{}"><code>Korg.load_exomol_partition_functions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_exomol_partition_functions()</code></pre><p>Loads the exomol partition funcstions for polyatomic molecules from the HDF5 archive. Returns a  dictionary mapping species to interpolators over log(T).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/read_statmech_quantities.jl#L161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.move_bounds-Union{Tuple{R}, Tuple{R, Vararg{Any, 4}}} where R&lt;:AbstractRange" href="#Korg.move_bounds-Union{Tuple{R}, Tuple{R, Vararg{Any, 4}}} where R&lt;:AbstractRange"><code>Korg.move_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">move_bounds(λs, lb0, ub0, λ₀, window_size)</code></pre><p>Using <code>lb0</code> and <code>ub0</code> as initial guesses, return the indices of <code>λs</code>, <code>(lb, ub)</code> corresponding to  <code>λ₀</code><code>±</code>window_size<code>.</code>λs` can either be a </p><ul><li>Vector, in which case <code>lb</code> and <code>ub</code> are used as first guesses</li><li>Range, in which case <code>lb</code> and <code>ub</code> are ignored and the bounds are computed directly</li><li>Vector of Ranges, in which case <code>lb</code> and <code>ub</code> are also ignored.  In this case, the bounds returned are indices into the concatenation of the ranges.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.n_atoms-Tuple{Korg.Formula}" href="#Korg.n_atoms-Tuple{Korg.Formula}"><code>Korg.n_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_atoms(x)</code></pre><p>The number of atoms in the Korg.Species or Korg.Formula x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/species.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.read_Barklem_Collet_table-Tuple{Any}" href="#Korg.read_Barklem_Collet_table-Tuple{Any}"><code>Korg.read_Barklem_Collet_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">functon read_Barklem_Collet_table(;transform=identity)</code></pre><p>Constructs a Dict holding tables containing partition function or equilibrium constant values across ln(temperature).  Applies transform (which you can use to, e.g. change units) to each example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/read_statmech_quantities.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.read_linelist-Tuple{String}" href="#Korg.read_linelist-Tuple{String}"><code>Korg.read_linelist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_linelist(filename; format=&quot;vald&quot;, isotopic_abundances=Korg.isotopic_abundances)</code></pre><p>Parse a linelist file, returning a vector of <a href="#Korg.Line-Union{Tuple{F}, Tuple{F, F, Korg.Species, F}, Tuple{F, F, Korg.Species, F, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}, Union{Missing, Tuple{F, F}, F}}} where F&lt;:Real"><code>Line</code></a>s.</p><p>The <code>format</code> keyword argument can be used to specify one of these linelist formats  (default: <code>&quot;vald&quot;</code>):</p><ul><li><code>&quot;vald&quot;</code> for a <a href="http://vald.astro.uu.se/~vald/php/vald.php">VALD</a> linelist.  These can be either &quot;short&quot; or &quot;long&quot; format,   &quot;extract all&quot; or &quot;extract stellar&quot;.  Air wavelengths will automatically be converted into vacuum  wavelengths, and energy levels will be automatically converted from cm<span>$^{-1}$</span> to eV.</li><li><code>&quot;kurucz&quot;</code> for a <a href="http://kurucz.harvard.edu/linelists.html">Kurucz linelist</a>   (format=kurucz_vac if it uses vacuum wavelengths; Be warned that Korg will not assume that   wavelengths are vacuum below 2000 Å),</li><li><code>&quot;moog&quot;</code> for a <a href="http://www.as.utexas.edu/~chris/moog.html">MOOG linelist</a>  (doesn&#39;t support broadening parameters or dissociation energies).  </li><li><code>&quot;turbospectrum&quot;</code> for a   <a href="https://github.com/bertrandplez/Turbospectrum2019/blob/master/DOC/Readme-Linelist_format_v.19">Turbospectrum linelist</a>   in air wavelengths. Note that Korg doesn&#39;t make use of the (optional) orbital angular momentum quantum number, l,   for the upper or lower levels, so it won&#39;t fall back on generic ABO recipes when the ABO   parameters are not available.  Korg&#39;s interpretation of the <code>fdamp</code> parameter is also slightly different from Turbospectrum&#39;s.  See the documentation of the <code>vdW</code> parameter of <a href="#Korg.Line-Union{Tuple{F}, Tuple{F, F, Korg.Species, F}, Tuple{F, F, Korg.Species, F, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}}, Tuple{F, F, Korg.Species, F, Union{Missing, F}, Union{Missing, F}, Union{Missing, Tuple{F, F}, F}}} where F&lt;:Real"><code>Line</code></a> for details.  Korg will error if   encounters an Unsoeld fudge factor, which it does not support.</li><li>&quot;turbospectrum_vac&quot; for a Turbospectrum linelist in vacuum wavelengths.</li></ul><p>For VALD and Turbospectrum linelists with isotope information available, Korg will scale log gf  values by isotopic abundance (unless VALD has already pre-scaled them), using isotopic abundances from <a href="https://www.nist.gov/pml/atomic-weights-and-isotopic-compositions-relative-atomic-masses">NIST</a>  ([Korg.isotopic<em>abundances]). To use custom isotopic abundances, just pass `isotopic</em>abundances` with the same structure:  a dict mapping atomic number to a dict mapping from atomic weight to abundance.</p><p>Be warned that for linelists which are pre-scaled for isotopic abundance, the estimation of  radiative broadening from log(gf) is not accurate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/linelist.jl#L135-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.read_model_atmosphere-Tuple{AbstractString}" href="#Korg.read_model_atmosphere-Tuple{AbstractString}"><code>Korg.read_model_atmosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_model_atmosphere(filename)</code></pre><p>Parse the provided model atmosphere file in MARCS &quot;.mod&quot; format.  Returns either a  <code>PlanarAtmosphere</code> or a <code>ShellAtmosphere</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Korg does not yet support cool (<span>$\lesssim$</span> 3500 K) stars.  While it will happily parse their model atmospheres, it may crash when you feed them into <code>synthesize</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/atmosphere.jl#L94-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.rectify-Union{Tuple{F}, Tuple{AbstractVector{F}, Any}} where F&lt;:Real" href="#Korg.rectify-Union{Tuple{F}, Tuple{AbstractVector{F}, Any}} where F&lt;:Real"><code>Korg.rectify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rectify(flux, wls; bandwidth=50, q=0.95, wl_step=1.0)</code></pre><p>Rectify the spectrum with flux vector <code>flux</code> and wavelengths <code>wls</code> by dividing out a moving <code>q</code>-quantile with window size <code>bandwidth</code>.  <code>wl_step</code> controls the size of the grid that the moving  quantile is calculated on and interpolated from.  Setting <code>wl_step</code> to 0 results in the exact  calculation with no interpolation, but note that this is very slow when the <code>wls</code> is sampled for  synthesis (~0.01 Å).</p><p>Experiments on real spectra show an agreement between the interpolated rectified spectrum and the  &quot;exact&quot; one (with default values) at the 3 × 10^-4 level.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function should not be applied to data with observational error, as taking a quantile will bias the rectification relative to the noiseless case.  It is intended as a fast way to compute nice-looking rectified theoretical spectra.  </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L92-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.saha_ion_weights-Tuple{Any, Any, Any, Any, Dict}" href="#Korg.saha_ion_weights-Tuple{Any, Any, Any, Any, Dict}"><code>Korg.saha_ion_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">saha_ion_weights(T, nₑ, atom, ionization_energies, partition_functions)</code></pre><p>Returns <code>(wII, wIII)</code>, where <code>wII</code> is the ratio of singly ionized to neutral atoms of a given  element, and <code>wIII</code> is the ration of doubly ionized to neutral atoms.</p><p>arguments:</p><ul><li>temperature <code>T</code> [K]</li><li>electron number density <code>nₑ</code> [cm^-3]</li><li>atom, the atomic number of the element </li><li><code>ionization_energies</code> is a collection indexed by integers (e.g. a <code>Vector</code>) mappping elements&#39;   atomic numbers to their first three ionization energies</li><li><code>partition_funcs</code> is a <code>Dict</code> mapping species to their partition functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/statmech.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.scaled_stark-Tuple{Any, Any}" href="#Korg.scaled_stark-Tuple{Any, Any}"><code>Korg.scaled_stark</code></a> — <span class="docstring-category">Method</span></header><section><div><p>the stark broadening gamma scaled acording to its temperature dependence</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.scaled_vdW" href="#Korg.scaled_vdW"><code>Korg.scaled_vdW</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scaled_vdW(vdW, m, T)</code></pre><p>The vdW broadening gamma scaled acording to its temperature dependence, using either simple scaling  or ABO. See Anstee &amp; O&#39;Mara (1995) or https://www.astro.uu.se/~barklem/howto.html for the definition of the ABO γ. </p><p><code>vdW</code> should be either <code>γ_vdW</code> evaluated at 10,000 K, or tuple containing the ABO params <code>(σ, α)</code>.  The species mass, <code>m</code>, is ignored in the former case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L265-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.setup_ionization_energies" href="#Korg.setup_ionization_energies"><code>Korg.setup_ionization_energies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setup_ionization_energies([filename])</code></pre><p>Parses the table of ionization energies and returns it as a dictionary mapping elements to their ionization energies, <code>[χ₁, χ₂, χ₃]</code> in eV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/read_statmech_quantities.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.setup_partition_funcs_and_equilibrium_constants-Tuple{}" href="#Korg.setup_partition_funcs_and_equilibrium_constants-Tuple{}"><code>Korg.setup_partition_funcs_and_equilibrium_constants</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setup_partition_funcs_and_equilibrium_constants()</code></pre><p>Returns two dictionaries. One holding the default patition functions, and one holding the default log10 equilibrium constants.</p><p><strong>Default partition functions</strong></p><p>The partition functions are custom (calculated from NIST levels) for atoms, from Barklem &amp;  Collet 2016 for diatomic molecules, and from <a href="https://exomol.com">exomol</a> for polyatomic molecules. For each molecule, we include only the most abundant isotopologue.</p><p>Note than none of these parition functions include plasma effects, e.g. via the Mihalas Hummer  Daeppen occupation probability formalism. They are for isolated species. This can lead to a couple percent error for neutral alkalis and to greater errors for hydrogen in  some atmospheres, particularly those of hot stars.</p><p><strong>Default equilibrium constants</strong></p><p>Molecules have equilibrium constants in addition to patition functions.  For the diatomics, these  are provided by Barklem and Collet, which extensively discusses the dissociation energies.  For  polyatomics, we calculate these ourselves, using atomization energies calculated from the enthalpies  of formation at 0K from <a href="https://cccbdb.nist.gov/hf0k.asp">NIST&#39;s CCCDB</a>.</p><p>Korg&#39;s equilbrum constants are in terms of partial pressures, since that&#39;s what Barklem and Collet  provide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/read_statmech_quantities.jl#L26-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.sigma_line-Tuple{Real}" href="#Korg.sigma_line-Tuple{Real}"><code>Korg.sigma_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sigma_line(wl)</code></pre><p>The cross-section (divided by gf) at wavelength <code>wl</code> in Ångstroms of a transition for which the  product of the degeneracy and oscillator strength is <code>10^log_gf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L287-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.synthesize" href="#Korg.synthesize"><code>Korg.synthesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">synthesize(atm, linelist, A_X, λ_start, λ_stop, [λ_step=0.01]; kwargs... )
synthesize(atm, linelist, A_X, wavelength_ranges; kwargs... )</code></pre><p>Compute a synthetic spectrum.</p><p><strong>Arguments</strong></p><ul><li><code>atm</code>: the model atmosphere (see <a href="../API/#Korg.read_model_atmosphere"><code>read_model_atmosphere</code></a>)</li><li><code>linelist</code>: A vector of [<code>Line]</code>(@ref)s (see <a href="../API/#Korg.read_linelist"><code>read_linelist</code></a>)</li><li><code>A_X</code>: a vector containing the A(X) abundances (log(X/H) + 12) for elements from hydrogen to  uranium.  (see <a href="../API/#Korg.format_A_X"><code>format_A_X</code></a>)</li><li><code>λ_start</code>: the lower bound (in Å) of the region you wish to synthesize.</li><li><code>λ_stop</code>: the upper bound (in Å) of the region you wish to synthesize.</li><li><code>λ_step</code> (default: 0.01): the (approximate) step size to take (in Å).</li></ul><p>If you provide a vector of wavelength ranges in place of <code>λ_start</code> and <code>λ_stop</code>, the spectrum will  be synthesized over each range with minimal overhead. The ranges can be any Julia <code>AbstractRange</code>, for example: <code>5000:0.01:5010</code>.</p><p><strong>Returns</strong></p><p>A named tuple with keys:</p><ul><li><code>flux</code>: the output spectrum</li><li><code>alpha</code>: the linear absorption coefficient at each wavelenth and atmospheric layer a Matrix of   size (layers x wavelengths)</li><li><code>number_densities</code>: A dictionary mapping <code>Species</code> to vectors of number densities at each   atmospheric layer</li><li><code>electron_number_density</code>: the electron number density at each atmospheric layer</li><li><code>wavelengths</code>: The vacuum wavelenths (in Å) over which the synthesis was performed.  If  <code>air_wavelengths=true</code> this will not be the same as the input wavelenths.</li><li><code>subspectra</code>: A vector of ranges which can be used to index into <code>flux</code> to extract the spectrum   for each range provided in <code>wavelength_ranges</code>.  If you use the standard <code>λ_start</code>, <code>λ_stop</code>,   <code>λ_step</code> arguments, this will be a vector containing only one range.</li></ul><p><strong>Example</strong></p><p>to synthesize a spectrum between 5000 Å and 5100 Å, with all metal abundances set to  0.5 dex less than the solar value except carbon, except carbon, which we set to [C/H]=-0.25:</p><pre><code class="nohighlight hljs">atm = read_model_atmosphere(&quot;path/to/atmosphere.mod&quot;)
linelist = read_linelist(&quot;path/to/linelist.vald&quot;)
A_X = format_A_X(-0.5, Dict(&quot;C&quot; =&gt; -0.25))
solution = synthesize(atm, linelist, A_X, 5000, 5100)</code></pre><p><strong>Optional arguments:</strong></p><ul><li><code>vmic</code> (default: 0) is the microturbulent velocity, <span>$\xi$</span>, in km/s.</li><li><code>air_wavelengths</code> (default: <code>false</code>): Whether or not the input wavelengths are air wavelenths to   be converted to vacuum wavelengths by Korg.  The conversion will not be exact, so that the   wavelenth range can internally be represented by an evenly-spaced range.  If the approximation   error is greater than <code>wavelength_conversion_warn_threshold</code>, an error will be thrown. (To do   wavelength conversions yourself, see <a href="../API/#Korg.air_to_vacuum"><code>air_to_vacuum</code></a> and <a href="../API/#Korg.vacuum_to_air"><code>vacuum_to_air</code></a>.)</li><li><code>wavelength_conversion_warn_threshold</code> (default: 1e-4): see <code>air_wavelengths</code>. (In Å.)</li><li><code>line_buffer</code> (default: 10): the farthest (in Å) any line can be from the provided wavelenth range   before it is discarded.  If the edge of your window is near a strong line, you may have to turn   this up.</li><li><code>cntm_step</code> (default 1): the distance (in Å) between point at which the continuum opacity is  calculated.</li><li><code>hydrogen_lines</code> (default: <code>true</code>): whether or not to include H lines in the synthesis.</li><li><code>use_MHD_for_hydrogen_lines</code> (default: <code>true</code>): whether or not to use the MHD occupation   probability formalism for hydrogen lines. (MHD is always used for hydrogen bound-free absorption.)</li><li><code>hydrogen_line_window_size</code> (default: 150): the mamximum distance (in Å) from each hydrogen line   center at which to calculate its contribution to the total absorption coefficient.</li><li><code>n_mu_points</code> (default: 20): the number of μ values at which to calculate the surface flux when doing   transfer in spherical geometry (when <code>atm</code> is a <code>ShellAtmosphere</code>). 20 points is sufficient for  accuracy at the 10^-3 level.</li><li><code>line_cutoff_threshold</code> (default: <code>3e-4</code>): the fraction of the continuum absorption coefficient   at which line profiles are truncated.  This has major performance impacts, since line absorption  calculations dominate more syntheses.  Turn it down for more precision at the expense of runtime.  The default value should effect final spectra below the 10^-3 level.</li><li><code>electron_number_density_warn_threshold</code> (default: <code>0.25</code>): if the relative difference between the   calculated electron number density and the input electron number density is greater than this value,  a warning is printed.</li><li><code>ionization_energies</code>, a <code>Dict</code> mapping <code>Species</code> to their first three ionization energies,   defaults to <code>Korg.ionization_energies</code>.</li><li><code>partition_funcs</code>, a <code>Dict</code> mapping <code>Species</code> to partition functions (in terms of ln(T)). Defaults   to data from Barklem &amp; Collet 2016, <code>Korg.default_partition_funcs</code>.</li><li><code>equilibrium_constants</code>, a <code>Dict</code> mapping <code>Species</code> representing diatomic molecules to the base-10  log of their molecular equilbrium constants in partial pressure form.  Defaults to data from   Barklem and Collet 2016, <code>Korg.default_log_equilibrium_constants</code>.</li><li><code>bezier_radiative_transfer</code> (default: false): Use the radiative transfer scheme.  This is for   testing purposes only.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/synthesize.jl#L5-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.translational_U-Tuple{Any, Any}" href="#Korg.translational_U-Tuple{Any, Any}"><code>Korg.translational_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">translational_U(m, T)</code></pre><p>The (inverse) contribution to the partition function from the free movement of a particle. Used in the Saha equation.</p><p>arguments</p><ul><li><code>m</code> is the particle mass</li><li><code>T</code> is the temperature in K</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/statmech.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.vacuum_to_air-Tuple{Any}" href="#Korg.vacuum_to_air-Tuple{Any}"><code>Korg.vacuum_to_air</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vacuum_to_air(λ; cgs=λ&lt;1)</code></pre><p>convert λ from a vacuum to air.  λ is assumed to be in Å if it is ⩾ 1, in cm otherwise.  Formula  from Birch and Downs (1994) via the VALD website.</p><p>See also: <a href="../API/#Korg.air_to_vacuum"><code>air_to_vacuum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.voigt_hjerting-Tuple{Any, Any}" href="#Korg.voigt_hjerting-Tuple{Any, Any}"><code>Korg.voigt_hjerting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">voigt_hjerting(α, v)</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Voigt_profile#Voigt_functions">Hjerting function</a>, <span>$H$</span>,  somtimes called the Voigt-Hjerting function. <span>$H$</span> is defined as <code>H(α, v) = ∫^∞_∞ exp(-y^2) / ((u-y)^2 + α^2) dy</code> (see e.g. the unnumbered equation after Gray equation 11.47).  It is equal to the ratio of the  absorption coefficient to the value of the absorption coefficient obtained at the line center with  only Doppler broadening.</p><p>If <code>x = λ-λ₀</code>, <code>Δλ_D = σ√2</code> is the Doppler width, and <code>Δλ_L = 4πγ</code> is the Lorentz width,</p><pre><code class="nohighlight hljs">voigt(x|Δλ_D, Δλ_L) = H(Δλ_L/(4πΔλ_D), x/Δλ_D) / (Δλ_D√π)
                    = H(γ/(σ√2), x/(σ√2)) / (σ√(2π))</code></pre><p>Approximation from <a href="https://ui.adsabs.harvard.edu/abs/1956ZA.....39...36H/abstract">Hunger 1965</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/line_absorption.jl#L330-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.λ_to_ν_bound-Tuple{Korg.Interval}" href="#Korg.λ_to_ν_bound-Tuple{Korg.Interval}"><code>Korg.λ_to_ν_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ_to_ν_bound(λ_bound)</code></pre><p>Converts a λ <code>Inverval</code> (in cm) to an equivalent ν <code>Interval</code> (in Hz), correctly accounting for  tricky floating point details at the bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/utils.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.CubicSplines.CubicSpline-Tuple{Any, Any}" href="#Korg.CubicSplines.CubicSpline-Tuple{Any, Any}"><code>Korg.CubicSplines.CubicSpline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CubicSpline(xs, ys; extrapolate=false)</code></pre><p>Construct a interpolant using <code>xs</code> and <code>ys</code> as the knot coordinates. Assumes <code>xs</code> is sorted. Apply  this object as a function to interpolate at any x value in the domain.  If <code>extrapolate</code> is false, x values outside [<code>xs[1]</code>, <code>xs[end]</code>] throw errors, if <code>extrapolate</code> is true, the interpolant uses flat extrapolation, i.e. it returns the extreme value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/CubicSplines.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.CubicSplines.cumulative_integral!-Tuple{Any, Korg.CubicSplines.CubicSpline, Any, Any}" href="#Korg.CubicSplines.cumulative_integral!-Tuple{Any, Korg.CubicSplines.CubicSpline, Any, Any}"><code>Korg.CubicSplines.cumulative_integral!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumulative_integral!(out, A, t1, t2)</code></pre><p>Given a curve described by the spine, A, Calculates the integral from t1 to t for all t = t1, t2, and  all spline knots in between.  So if <code>t1</code> is <code>A.t[1]</code> and <code>t2</code> is <code>A.t[end]</code>, <code>out</code> should have the  same length as <code>A.t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/CubicSplines.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.H_I_bf-NTuple{6, Any}" href="#Korg.ContinuumAbsorption.H_I_bf-NTuple{6, Any}"><code>Korg.ContinuumAbsorption.H_I_bf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H_I_bf(νs, T, nH, nHe, ne, invU_H; n_max_MHD=6, use_hubeny_generalization=false, 
       taper=false, use_MHD_for_Lyman=false)</code></pre><p>The bound-free linear absorption coefficient contributed by all energy states of a neutral Hydrogen  atom. Even though the Mihalas-Hummer-Daeppen (MHD) occupation probability formalism is not used in Korg when computing the hydrogen partition function, it is used here. That means that series limit jumps (e.g. the Balmer jump), are &quot;rounded off&quot;, as photons with less than the &quot;classical&quot;  ionization energy can ionize if the upper level is dissolved into the continuum.</p><p><strong>Required Arguments</strong></p><ul><li><code>νs</code>: sorted frequency vector in Hz</li><li><code>T</code>: temperature in K</li><li><code>nH_I</code>: the total number density of neutral Hydrogen (in cm⁻³)</li><li><code>nHe_I</code>: the total number density of neutral Helium (in cm⁻³)</li><li><code>ne</code>: the number density of electrons (in cm⁻³)</li><li><code>invU_H</code>: The inverse of the neutral hydrogen partition function (neglecting contributions from the MHD formalism)</li></ul><p>For n=1 through n=<code>n_max_MHD</code> (default: 6), the cross-sections are computed using  <a href="https://ui.adsabs.harvard.edu/abs/2021Atoms...9...73N/abstract">Nahar 2021</a>.  These are modified using the MHD formalism to account for level dissolution.   For larger n, the cross-sections are calculated with a simple analytic formula (see  <a href="#Korg.ContinuumAbsorption.simple_hydrogen_bf_cross_section-Tuple{Integer, Real}"><code>simple_hydrogen_bf_cross_section</code></a>).</p><p>Because MHD level dissolution applied to the the Lyman series limit leads to inflated cross-sections in the visible, we don&#39;t use MHD for bf absorption from n=1.  This can be overridden by setting <code>use_MHD_for_Lyman=true</code>, in which case you will also want to set <code>taper=true</code>, which the same  tapering of the cross-section as <a href="https://github.com/barklem/hlinop/blob/master/hbop.f">HBOP</a> to fix  the problem.</p><p>The <code>use_hubeny_generalization</code> keyword argument enables the generalization of the MHD from  Hubeny 1994. It is experimental and switched off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/absorption_H.jl#L22-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption._load_gauntff_table" href="#Korg.ContinuumAbsorption._load_gauntff_table"><code>Korg.ContinuumAbsorption._load_gauntff_table</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_load_gauntff_table([fname])</code></pre><p>Returns a table of thermally-averaged free-free Gaunt factors, and the values of log₁₀(γ²) and log₁₀(u) associated with each point.</p><p>This loads the non-relativistic free-free data published by <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.444..420V/abstract">van Hoof et al. (2014)</a>.</p><p>Note: This function code could trivially be adapted to load the relativistic free-free gaunt factors published by <a href="https://ui.adsabs.harvard.edu/abs/2015MNRAS.449.2112V/abstract">van Hoof et al (2015)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/hydrogenic_bf_ff.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption._ndens_Hminus" href="#Korg.ContinuumAbsorption._ndens_Hminus"><code>Korg.ContinuumAbsorption._ndens_Hminus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_ndens_Hminus(nH_I_div_partition, ne, T, ion_energy = _H⁻_ion_energy)</code></pre><p>Compute the number density of H⁻ (implements eqn 5.10 of Kurucz 1970). This is an application of the saha equation where the &quot;ground state&quot; is H⁻ and the &quot;first ionization state&quot; is H I. The partition function of H⁻ is 1 at all temperatures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/absorption_H.jl#L176-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.bounds_checked_absorption-Tuple{Any}" href="#Korg.ContinuumAbsorption.bounds_checked_absorption-Tuple{Any}"><code>Korg.ContinuumAbsorption.bounds_checked_absorption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounds_checked_absorption(func; ν_bound, temp_bound)</code></pre><p>Constructs a wrapped function that implements bounds checking and extrapolation</p><p><strong>Parameters</strong></p><ul><li><code>func</code>: a function that has a signature <code>f(ν::Real, T::Real, args...)::Real</code>, where <code>ν</code> is  frequency (in Hz) and <code>T</code> is temperature (in K)</li><li><code>ν_bound::Interval</code>: Interval of frequencies (in Hz) over which <code>func</code> is valid.</li><li><code>temp_bound::Interval</code>: Interval of temperatures (in K) over which <code>func</code> is valid.</li></ul><p>The resulting function will have this signature:</p><pre><code class="nohighlight hljs">wrapped_func(ν::AbstractVector{&lt;:Real}, T::Real, args...; kwargs...)</code></pre><p><strong>Wrapped Function Parameters</strong></p><ul><li><code>ν::AbstractVector{&lt;:Real}</code>: sorted vector of frequencies (in Hz)</li><li><code>T::Real</code>: temperature (in K)</li><li><code>args...</code>: function-specific arguments</li></ul><p>For a description for the <code>kwargs...</code>, see <a href="../API/#Continuum-Absorption-Kwargs">Continuum Absorption Kwargs</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/bounds_checking.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.electron_scattering-Tuple{F} where F&lt;:Real" href="#Korg.ContinuumAbsorption.electron_scattering-Tuple{F} where F&lt;:Real"><code>Korg.ContinuumAbsorption.electron_scattering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electron_scattering(nₑ)</code></pre><p>Compute the linear absorption coefficient, α, from scattering off of free electrons. This has no wavelength dependence. It assumes isotropic scattering.  (See, e.g. Gray p 160.)</p><p><strong>Arguments</strong></p><ul><li><code>nₑ::F</code>: number density of free electrons (in cgs)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/scattering.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.gaunt_ff_vanHoof-Tuple{Any, Any}" href="#Korg.ContinuumAbsorption.gaunt_ff_vanHoof-Tuple{Any, Any}"><code>Korg.ContinuumAbsorption.gaunt_ff_vanHoof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaunt_ff_vanHoof(log_u, log_γ2)</code></pre><p>computes the thermally averaged, non-relativistic free-free gaunt factor by interpolating the table provided by <a href="https://ui.adsabs.harvard.edu/abs/2014MNRAS.444..420V">van Hoof et al. (2014)</a>.</p><p><strong>Arguments</strong></p><ul><li><code>log_u</code>: Equal to log₁₀(u) = log₁₀(h<em>ν/(k</em>Tₑ))</li><li><code>log_γ2</code>: Equal to log₁₀(γ²) = log₁₀(Rydberg<em>Z²/(k</em>Tₑ))</li></ul><p><code>Rydberg</code> is the &quot;infinite mass unit of energy&quot; and <code>Tₑ</code> is the temperature of free electrons (for our purposes, we assume that free electrons are in thermal equilibrium with ions and neutral species).</p><p><strong>Notes</strong></p><p>van Hoof et al. (2014) computed the associated data table with a non-relativistic approach, which is invalid at very high temperatures. They conclude (from comparisons with a different paper) that their &quot;results should be accurate up to electron temperatures of roughly 100 MK&quot;. This is more than adequate for stellar atmospheres. In <a href="https://ui.adsabs.harvard.edu/abs/2015MNRAS.449.2112V">van Hoof et al. (2015)</a>, they find that relativistic effects introduce a ∼0.75% at 100MK, for Z = 1 (when Z &gt; 1, the change is smaller).</p><p>This function currently uses linear interpolation. However, van Hoof et al. (2014) provides an implementation of a third-order Lagrange scheme, which &quot;reaches a relative precision better than 1.5e-4 everywhere.&quot; The C and Fortran implementations of this scheme can be found <a href="http://data.nublado.org/gauntff/">here</a>, and are copyrighted by a BSD-style license.</p><p>Earlier variants of this function used less-accurate data from section 5.1 of Kurucz (1970) that extended over a smaller interval of data. That table was originally derived from a figure in Karsas and Latter (1961) and it&#39;s now used for testing purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/hydrogenic_bf_ff.jl#L83-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.hydrogenic_ff_absorption-Tuple{Real, Real, Integer, Real, Real}" href="#Korg.ContinuumAbsorption.hydrogenic_ff_absorption-Tuple{Real, Real, Integer, Real, Real}"><code>Korg.ContinuumAbsorption.hydrogenic_ff_absorption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydrogenic_ff_absorption(ν, T, Z, ni, ne)</code></pre><p>computes the free-free linear absorption coefficient for a hydrogenic species</p><p>The naming convention for free-free absorption is counter-intuitive. A free-free interaction is named as though the species interacting with the free electron had one more bound electron (in  other words it&#39;s named as though the free-electron and ion were bound together). In practice, this means that <code>ni</code> should refer to:</p><ul><li>the number density of H II if computing the H I free-free absorption</li><li>the number density of He III if computing the He II free-free absorption</li><li>the number density of Li IV if computing the Li III free-free absorption</li></ul><p><strong>Arguments</strong></p><ul><li><code>Z::Integer</code>: the charge of the ion. For example, this is 1 for ionized H.</li><li><code>ni</code>: the number density of the ion species in cm⁻³.</li><li><code>ne</code>: the number density of free electrons.</li><li><code>ν</code>: frequency in Hz</li><li><code>T</code>: temperature in K</li></ul><p><strong>Note</strong></p><p>This approach was adopted from equation 5.8 from section 5.1 of Kurucz (1970). Comparison against equation 5.18b of Rybicki &amp; Lightman (2004), reveals that the equation in Kurucz (1970) omits the dependence on ρ. According to Rybicki &amp; Lightman (2004) the free-free absorption coefficient (corrected for stimulated emission) is:</p><pre><code class="nohighlight hljs">    α = coef * Z² * ne * ni * (1 - exp(-hplanck*ν/(kboltz*T))) * g_ff / (sqrt(T) * ν³)</code></pre><p>Note that the g_ff is the free-free gaunt factor and coef is ∼3.7e8 (a more exact coefficient can be computed from eqn 5.18a).</p><p>With this in mind, equation 5.8 of Kurucz (1970) should actually read</p><pre><code class="nohighlight hljs">    κ = ne * n(H II) * F_ν(T) * (1 - exp(-hplanck*ν/(kboltz*T))) / ρ</code></pre><p>where F<em>ν(T) = coef * Z² * g</em>ff / (sqrt(T) * ν³).</p><p>See <code>gaunt_ff_vanHoof</code> for details about where our gaunt factor data comes from. For simplicity, we enforce temperature and ν bounds constraints that don&#39;t include all of the available gaunt factor data. In practice, this should never be a concern for stellar spectroscopy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/hydrogenic_bf_ff.jl#L117-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.metal_bf_absorption!-NTuple{4, Any}" href="#Korg.ContinuumAbsorption.metal_bf_absorption!-NTuple{4, Any}"><code>Korg.ContinuumAbsorption.metal_bf_absorption!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">metal_bf_absorption!(α, νs, T, number_densities)</code></pre><p>Adds to α the contributions of bf metal opacities.  Uses precomputed tables from  <a href="http://cdsweb.u-strasbg.fr/topbase/topbase.html">TOPBase</a> for Li, Be, B, C, N, O, F, Ne, Na, Mg,  Al, Si, S, Ar, and Ca. Uses tables from  <a href="https://www.astronomy.ohio-state.edu/nahar.1/nahar_radiativeatomicdata/index.html">NORAD</a> for  Fe.  For these elements, tables have been precomputed for the neutral and singly ionized species  assuming and LTE distribution of energy levels.  See <code>Korg/data/metal_bf_cross-sections/</code> for the scripts which generate the tables.</p><p>Cross sections were computed for 100 K &lt; T &lt; 100,000 K and frequencies corresponding to  500 Å &lt; λ &lt; 30,000 Å.  Outside of either of those ranges, flat extrapolation is used (i.e. the  extreme value is returned).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/absorption_metals_bf.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.positive_ion_ff_absorption!-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real, Dict, Real}" href="#Korg.ContinuumAbsorption.positive_ion_ff_absorption!-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real, Dict, Real}"><code>Korg.ContinuumAbsorption.positive_ion_ff_absorption!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">positive_ion_ff_absorption!(α_out::Vector{Real}, ν::Real, T::Real, number_densities::Dict, 
                            ne::Real, departure_coefficients=Peach1970.departure_coefficients)</code></pre><p>Computes the linear absorption coefficient (in cm⁻¹) for all free-free interactions involving positively charged atomic species. Uses the provided departure coefficients when they are available, and the uncorrected hydrogenic approximation when they are not.</p><p><strong>Arguments</strong></p><ul><li><code>ν</code>: frequency in Hz</li><li><code>T</code>: temperature in K</li><li><code>number_densities</code> is a <code>Dict</code> mapping each <code>Species</code> to its number density.</li><li><code>ne</code>: the number density of free electrons.</li><li><code>departure_coefficients</code> (optional, defaults to   <code>ContinuumAbsorption.Peach1970.departure_coefficients</code>:   a dictionary mapping species to the departure coefficients for the ff process it participates in   (e.g. <code>species&quot;C II&quot;</code> maps to the C III ff departure coefficients–see note below).  Departure  coefficients should be callables taking temperature and (photon energy / RydbergH / Zeff^2).  </li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A free-free interaction is named as though the species interacting with the free electron had  one more bound electron (in other words it&#39;s named as though the free-electron and ion were  bound together). To make matters more confusing, some sources present the free-free linear  absorption coefficient&#39;s formula in terms of the number density of the species in the  interaction&#39;s name (by including the Saha equation in the formula).</p><p>To compute the absorption for a given free-free interaction, this function accesses elements  from the dictionary arguments that are associated with the species that participates in the  interaction. For example:</p><ul><li>Si I ff absorption: uses the number density of Si II (<code>number_densities[species&quot;Si II&quot;]</code>) and checks <code>departure_coefficients[species&quot;Si II&quot;]</code> for departure coefficients.</li><li>Si II ff absorption: uses the number density of Si III (<code>number_densities[species&quot;Si III&quot;]</code>) and checks <code>departure_coefficients[species&quot;Si III&quot;]</code> for departure coefficients.</li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/absorption_ff_positive_ion.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.rayleigh-Tuple{AbstractVector{&lt;:Real}, Any, Any, Any}" href="#Korg.ContinuumAbsorption.rayleigh-Tuple{AbstractVector{&lt;:Real}, Any, Any, Any}"><code>Korg.ContinuumAbsorption.rayleigh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rayleigh(λs, nH_I, nHe_II, nH2)</code></pre><p>Absorption coefficient from Rayleigh scattering by neutral H, He, and H2.  Formulations for H and He are via <a href="https://ui.adsabs.harvard.edu/abs/2016ApJ...817..116C/abstract">Colgan+ 2016</a>.  Formulation  for H2 from  <a href="https://ui.adsabs.harvard.edu/abs/1962ApJ...136..690D/abstract">Dalgarno and Williams 1962</a>.</p><p>The Dalgarno and Williams H2 is applicable redward of 1300 Å.  Since Rayleigh scattering breaks down when the particle size to wavelength ratio gets large, we that all frequencies passed to this  function be equivalent to 1300 Å or greater.</p><p>The formulations for H is adapted from  <a href="https://ui.adsabs.harvard.edu/abs/1962ApJ...136..690D/abstract">Lee 2005</a>, which states that it is  applicable redward of Lyman alpha. See Colgan 2016 for details on He.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/scattering.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.simple_hydrogen_bf_cross_section-Tuple{Integer, Real}" href="#Korg.ContinuumAbsorption.simple_hydrogen_bf_cross_section-Tuple{Integer, Real}"><code>Korg.ContinuumAbsorption.simple_hydrogen_bf_cross_section</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simple_hydrogen_bf_cross_section(n::Integer, ν::Real)</code></pre><p>Calculate the H I bf cross section in megabarns using a very simple approximation.  See, for  example, Kurucz 1970 equation 5.5 (though see note below).  This implementation is used to  extrapolate the cross-section past the ionization energy of an unperturbed hydrogen atom, as is  required to take level dissolution into account with the MHD formalism.</p><p>Equation 5.5 of Kurucz had a typo in it. In the numerator of the fraction that is multiplied by the  entire polynomial, Z² should be Z⁴. This was discovered during comparisons with data from the  Opacity Project, and can be confirmed by looking at eqn 5.6 of Kurucz (it uses Z⁴ instead of Z²) or by comparison against equation 10.54 of Rybicki &amp; Lightman.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/absorption_H.jl#L134-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.total_continuum_absorption-Tuple{Any, Any, Any, Dict, Dict}" href="#Korg.ContinuumAbsorption.total_continuum_absorption-Tuple{Any, Any, Any, Dict, Dict}"><code>Korg.ContinuumAbsorption.total_continuum_absorption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_continuum_absorption(νs, T, nₑ, number_densities, partition_funcs; error_oobounds)</code></pre><p>The total continuum linear absoprtion coefficient, α, at many frequencies, ν.</p><p><strong>Arguments</strong></p><ul><li><code>νs</code> are frequencies in Hz</li><li><code>T</code> is temperature in K</li><li><code>nₑ</code> is the electron number density in cm^-3</li><li><code>number_densities</code> is a <code>Dict</code> mapping each <code>Species</code> to its number density</li><li><code>partition_funcs</code> is a <code>Dict</code> mapping each <code>Species</code> to its partition function (e.g. <code>Korg.partition_funcs</code>)</li><li><code>error_oobounds::Bool</code> specifies the behavior of most continnum absorption sources when passed  frequencies or temperature values that are out of bounds for their implementation. When <code>false</code>  (the default), those absorption sources are ignored at those values. Otherwise, an error is  thrown.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For efficiency reasons, <code>νs</code> must be sorted. While this function technically supports any  sorted <code>AbstractVector</code>, it is most effient when passed an  <code>AbstractRange</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/ContinuumAbsorption.jl#L16-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.Stancil1994" href="#Korg.ContinuumAbsorption.Stancil1994"><code>Korg.ContinuumAbsorption.Stancil1994</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module contains transcriptions of the tables from  <a href="https://ui.adsabs.harvard.edu/abs/1994ApJ...430..360S/abstract">Stancil 1994</a>, who calculated ff  and bf absorption coefficients for H₂⁺ and He₂⁺.</p><p>It also contains pre-constructed interpolation objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/Stancil1994.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.ContinuumAbsorption.Peach1970.departure_coefficients-Tuple{}" href="#Korg.ContinuumAbsorption.Peach1970.departure_coefficients-Tuple{}"><code>Korg.ContinuumAbsorption.Peach1970.departure_coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Peach1970.departure_coefficients()</code></pre><p>This module contains interpolators of the tabulated ff departure coeffients from  <a href="https://ui.adsabs.harvard.edu/abs/1970MmRAS..73....1P/abstract">Peach+ 1970</a>, which we use to  correct the hydrogenic ff absorption coefficient for H I ff, C I ff, Si I ff, and Mg I ff.  It contains a dictionary (returned by <code>departure_coefficients()</code>), which maps <code>Species</code> to  interpolator objects.  Crucially, the dictionary is indexed by the species which actually  participates in the interaction, not the one after which the interaction is named.  </p><p>Outside the regime in which Peach 1970 provides data, the interpolators return 0, falling back to  the hydreogenic approximation.</p><p>The species for which we use corrections are the same species which get corrected in  MARCS/Turbospectrum (see Table 1 of  <a href="https://ui.adsabs.harvard.edu/abs/2008A%26A...486..951G/abstract">Gustafsson+ 2008</a>). The choices seem are largely motivated by which species have departure terms at normal stellar atmosphere conditions and which species are most abundant in the sun. For C II ff,  we include only the contribution from the ¹S parent term, even though (in contrast to other  speices) information is available for the ³Pᵒ term as well.</p><p>The free-free absorption coefficient (including stimulated emission) is given by:</p><p><span>$\alpha_{ m ff} = \alpha_{ m hydrogenic, ff}(\nu, T, n_i, n_e; Z) (1 + D(T, \sigma))$</span>,</p><p>where</p><ul><li><span>$\alpha_{ m hydrogenic, ff}(\nu, T, n_i, n_e; Z)$</span> should include the correction for  stimulated emission.</li><li><span>$n_i$</span> is the number density fo the ion species that participates in the interation, not the  species the interaction is named after.</li><li><span>$n_e$</span> is the number density of free electrons.</li><li><span>$D(T, \sigma)$</span> is specified as the <code>departure</code> arg, and is expected to interpolate over</li></ul><p>the tabulated values specified in Table III of Peach (1970).</p><ul><li>σ denotes the energy of the photon in units of RydbergH*Zeff²</li></ul><p>It might not be immediately obvious how the above equation relates to the equations presented in Peach (1970). Peach describes the calculation for <span>$k_ u^F$</span>, the free-free absorption  coefficient (uncorrected for stimulated emission) per particle of the species that the interaction  is named after. In other words, he computes:</p><p><span>$k_ u^F = \alpha_{ m ff}/n_{i-1} \left(1 - e^\frac{-h\nu}{k T}\right)^{-1}$</span>,</p><p>where <span>$n_{i-1}$</span> is the number density of the species that the interaction is named after. <span>$k_ u^F$</span> can directly be computed, under LTE, from just <span>$u$</span>, <span>$T$</span>, and <span>$n_{i-1}$</span> (the Saha Equation relates <span>$\alpha_{ m ff}$</span>&#39;s dependence on <span>$n_e$</span> and <span>$n_i$</span> to <span>$n_{i-1}$</span> and  <span>$T$</span>.  Gray (2005) follows a similar convention when describing free-free absorption.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The tabulated data in this module was taken from Peach 1970 using OCR software, and may  contain mis-read values, although they produce reasonable behavior and there are no obvious  problems.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/ContinuumAbsorption/Peach1970.jl#L278-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.generate_mu_grid-Tuple{Any}" href="#Korg.RadiativeTransfer.generate_mu_grid-Tuple{Any}"><code>Korg.RadiativeTransfer.generate_mu_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_mu_grid(n_points)</code></pre><p>Used by both radiative transfer schemes to compute quadature over μ. Returns <code>(μ_grid, μ_weights)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/RadiativeTransfer.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer" href="#Korg.RadiativeTransfer.MoogStyleTransfer"><code>Korg.RadiativeTransfer.MoogStyleTransfer</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Korg&#39;s default radiative transfer implementation.  See also: <code>RadiativeTransfer.BezierTransfer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer._plane_parallel_approximate_transfer_integral-Tuple{Any, Any, Any}" href="#Korg.RadiativeTransfer.MoogStyleTransfer._plane_parallel_approximate_transfer_integral-Tuple{Any, Any, Any}"><code>Korg.RadiativeTransfer.MoogStyleTransfer._plane_parallel_approximate_transfer_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_plane_parallel_approximate_transfer_integral(τ, m, b)</code></pre><p>The exact solution to <span>$\int (m\tau + b) E_2(\tau)$</span> d\tau$.</p><p>The exponential integral function, expint, captures the integral over the disk of the star to  get the emergent astrophysical flux. You can verify it by substituting the variable of integration  in the exponential integal, t, with mu=1/t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.all_mu_transfer_integral-Tuple{Any, Any}" href="#Korg.RadiativeTransfer.MoogStyleTransfer.all_mu_transfer_integral-Tuple{Any, Any}"><code>Korg.RadiativeTransfer.MoogStyleTransfer.all_mu_transfer_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_mu_transfer_integral(τ, S)</code></pre><p>Compute exactly the solution to the transfer integral obtained be linearly interpolating the source  function, <code>S</code> across optical depths <code>τ</code>, without approximating the factor of E₂(τ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.cumulative_trapezoid_rule!" href="#Korg.RadiativeTransfer.MoogStyleTransfer.cumulative_trapezoid_rule!"><code>Korg.RadiativeTransfer.MoogStyleTransfer.cumulative_trapezoid_rule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cumulative_trapezoid_rule!(out, xs, fs, [len=length(xs)])</code></pre><p>Approximate the closed integral of f(x) from the first element of <code>xs</code> to each element of <code>xs</code>  (up to <code>len</code>) with the trapezoid rule, given f values <code>fs</code>. </p><p>Assigns to the preallocated vector <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L185-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.exponential_integral_2-Tuple{Any}" href="#Korg.RadiativeTransfer.MoogStyleTransfer.exponential_integral_2-Tuple{Any}"><code>Korg.RadiativeTransfer.MoogStyleTransfer.exponential_integral_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exponential_integral_2(x)</code></pre><p>Approximate second order exponential integral, E_2(x).  This stiches together several series  expansions to get an approximation which is accurate within 1% for all <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.planar_transfer-NTuple{4, Any}" href="#Korg.RadiativeTransfer.MoogStyleTransfer.planar_transfer-NTuple{4, Any}"><code>Korg.RadiativeTransfer.MoogStyleTransfer.planar_transfer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">planar_transfer(α, S, τ_ref, α_ref)</code></pre><p>Returns the astrophysical flux. See <a href="#Korg.RadiativeTransfer.MoogStyleTransfer.radiative_transfer"><code>radiative_transfer</code></a> for an explantion of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.radiative_transfer" href="#Korg.RadiativeTransfer.MoogStyleTransfer.radiative_transfer"><code>Korg.RadiativeTransfer.MoogStyleTransfer.radiative_transfer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">radiative_transfer(atm::ModelAtmosphere, α, S, α_ref, mu_grid)</code></pre><p>Returns the astrophysical flux at each wavelength.</p><p>inputs:</p><ul><li><code>atm</code>: the model atmosphere.</li><li><code>α</code>: a matrix (atmospheric layers × wavelengths) containing the absoprtion coefficient</li><li><code>S</code>: the source fuction as a matrix of the same shape.</li><li><code>α_ref</code>: the continuum absoprtion coefficient at the reference wavelength (5000 Å). Used to   rescale the total absorption to match the model atmosphere. This value should be calculated by   Korg.</li><li><code>mu_grid</code>: (required if atm is a <a href="#Korg.ShellAtmosphere-Tuple{Korg.PlanarAtmosphere, Any}"><code>ShellAtmosphere</code></a>) the values of μ at which to calculate   the surface intensity, which is integrated to obtain the astrophysical flux.</li></ul><p>Keyword arguments:</p><ul><li><code>n_nu_points</code>: the number of rays to use when integrating over I_surface(μ) to obtain the   astrophysical flux.  This doesn&#39;t do anything if <code>atm</code> is a <a href="#Korg.PlanarAtmosphere-Tuple{Korg.ShellAtmosphere}"><code>PlanarAtmosphere</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L9-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.ray_transfer_integral-Tuple{Any, Any}" href="#Korg.RadiativeTransfer.MoogStyleTransfer.ray_transfer_integral-Tuple{Any, Any}"><code>Korg.RadiativeTransfer.MoogStyleTransfer.ray_transfer_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ray_transfer_integral(τ, S)</code></pre><p>Compute exactly the solution to the transfer integral obtained be linearly interpolating the source  function, <code>S</code> across optical depths <code>τ</code>, without approximating the factor of exp(-τ).</p><p>This breaks the integral into the sum of integrals of the form  <span>$\int (m\tau + b) \exp(-\tau)$</span> d\tau$ ,  which is equal to $ -\exp(-\tau) (m*\tau + b + m)$.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.MoogStyleTransfer.spherical_transfer-NTuple{6, Any}" href="#Korg.RadiativeTransfer.MoogStyleTransfer.spherical_transfer-NTuple{6, Any}"><code>Korg.RadiativeTransfer.MoogStyleTransfer.spherical_transfer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spherical_transfer(α, S, τ_ref, α_ref, radii, μ_surface_grid)</code></pre><p>Perform radiative transfer along rays emerging at the μ values in <code>μ_surface_grid</code> in a spherically symmetric atmosphere resolved at radii <code>radii</code> [cm]. See <a href="#Korg.RadiativeTransfer.MoogStyleTransfer.radiative_transfer"><code>radiative_transfer</code></a> for an  explantion of the arguments. Note that <code>radii</code> should be in decreasing order.</p><p>Returns <code>(flux, intensity)</code>, where <code>flux</code> is the astrophysical flux, and <code>intensity</code>, a matrix of  shape (mu values × wavelengths), is the surface intensity as a function of μ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/MoogStyleTransfer.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer" href="#Korg.RadiativeTransfer.BezierTransfer"><code>Korg.RadiativeTransfer.BezierTransfer</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Functions to solve the radiative transfer formal solution using the  <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...33D/abstract">de la Cruz Rodríguez and Piskunov method</a>.</p><p>We would like to migrate to this transfer implementation as the default eventually, but it doens&#39;t  seem to perform much better than <code>RadiativeTransfer.MoogStyleTransfer</code>` in practice.  The treatment  of both the path-length (ds) and what happens at the midplane of the star are more careful in this  implementation, but it&#39;s not yet as fast and it doesn&#39;t produce results any closer to the MARCS flux  files (even when adjusting the absorption coeffs to match the MARCS numbers).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.compute_tau_bezier!-Tuple{Any, Any, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.compute_tau_bezier!-Tuple{Any, Any, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.compute_tau_bezier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_tau_bezier(τ, s, α)</code></pre><p>Compute optical depth (write to τ) along a ray with coordinate s and absorption coefficient α.  This  is the method proposed in  <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...33D/abstract">de la Cruz Rodríguez and Piskunov 2013</a>, but the </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.compute_tau_spline_analytic!-Tuple{Any, Any, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.compute_tau_spline_analytic!-Tuple{Any, Any, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.compute_tau_spline_analytic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_tau_spline_analytic(τ, s, α)</code></pre><p>Compute τ using a cubic spline to interpolate α.  This is not used by <a href="#Korg.RadiativeTransfer.BezierTransfer.radiative_transfer-Tuple{Korg.PlanarAtmosphere, Any, Any, Any}"><code>radiative_transfer</code></a>, but is included for completeness.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.fritsch_butland_C-Tuple{Any, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.fritsch_butland_C-Tuple{Any, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.fritsch_butland_C</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fritsch_butland_C(x, y)</code></pre><p>Given a set of x and y values, compute the bezier control points using the method of  <a href="https://doi.org/10.1137/0905021">Fritch &amp; Butland 1984</a>, as suggested in  <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...33D/abstract">de la Cruz Rodríguez and Piskunov 2013</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.planar_transfer-NTuple{4, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.planar_transfer-NTuple{4, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.planar_transfer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">planar_transfer(α, S, z, n_μ_points)</code></pre><p>Perform radiative transfer in a planar atmosphere. See <a href="#Korg.RadiativeTransfer.BezierTransfer.radiative_transfer-Tuple{Korg.PlanarAtmosphere, Any, Any, Any}"><code>radiative_transfer</code></a> for an  explantion of the arguments. </p><p>Returns <code>(flux, intensity)</code>, where <code>flux</code> is the astrophysical flux, and <code>intensity</code>, a matrix of  shape (mu values × wavelengths), is the surface intensity as a function of μ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.radiative_transfer-Tuple{Korg.PlanarAtmosphere, Any, Any, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.radiative_transfer-Tuple{Korg.PlanarAtmosphere, Any, Any, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.radiative_transfer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radiative_transfer(atm::ModelAtmosphere, α, S, n_μ_points)</code></pre><p>Returns the astrophysical flux at each wavelength.</p><p>inputs:</p><ul><li><code>atm</code>: the model atmosphere.</li><li><code>α</code>: a matrix (atmospheric layers × wavelengths) containing the absoprtion coefficient</li><li><code>S</code>: the source fuction as a matrix of the same shape.  rescale the total absorption to match the model atmosphere. This value should be calculated by   Korg.</li><li><code>n_μ_points</code>: the number of quadrature points to use when integrating over I_surface(μ) to obtain   the astrophysical flux.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L15-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.ray_transfer_integral-Tuple{Any, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.ray_transfer_integral-Tuple{Any, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.ray_transfer_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ray_transfer_integral(τ, S)</code></pre><p>Given τ and S along a ray (at a particular wavelength), compute the intensity at the end of the ray  (the surface of the star).  This uses the method from  <a href="https://ui.adsabs.harvard.edu/abs/2013ApJ...764...33D/abstract">de la Cruz Rodríguez and Piskunov 2013</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Korg.RadiativeTransfer.BezierTransfer.spherical_transfer-NTuple{4, Any}" href="#Korg.RadiativeTransfer.BezierTransfer.spherical_transfer-NTuple{4, Any}"><code>Korg.RadiativeTransfer.BezierTransfer.spherical_transfer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spherical_transfer(α, S, τ_ref, α_ref, radii, μ_surface_grid)</code></pre><p>Perform radiative transfer along rays emerging in a spherically symmetric atmosphere resolved at  radii <code>radii</code> [cm]. See <a href="#Korg.RadiativeTransfer.BezierTransfer.radiative_transfer-Tuple{Korg.PlanarAtmosphere, Any, Any, Any}"><code>radiative_transfer</code></a> for an explantion of the arguments. Note that  <code>radii</code> should be in decreasing order.</p><p>Returns <code>(flux, intensity)</code>, where <code>flux</code> is the astrophysical flux, and <code>intensity</code>, a matrix of  shape (mu values × wavelengths), is the surface intensity as a function of μ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/Korg.jl/blob/d83cd187ed6c9439b3cbbe7a66a1f84a10b586ac/src/RadiativeTransfer/BezierTransfer.jl#L74-L83">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../changelog/">« Changelog</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 30 June 2023 13:10">Friday 30 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
