<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>All Functions · SSSynth Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SSSynth Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Quickstart</a></li><li class="is-active"><a class="tocitem" href>All Functions</a></li><li><a class="tocitem" href="../refs/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>All Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>All Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ajwheeler/SSSynth.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>This is an automatically generated list of all functions in no particular order.  In future, we  should organize this and add context.</p><article class="docstring"><header><a class="docstring-binding" id="SSSynth.Line" href="#SSSynth.Line"><code>SSSynth.Line</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This type represents an individual line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.Line-Union{Tuple{F}, Tuple{F, F, String, F}} where F" href="#SSSynth.Line-Union{Tuple{F}, Tuple{F, F, String, F}} where F"><code>SSSynth.Line</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a <code>Line</code> without explicit broadening parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L84-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.blackbody-Tuple{Any, Any}" href="#SSSynth.blackbody-Tuple{Any, Any}"><code>SSSynth.blackbody</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blackbody(T, λ)</code></pre><p>The value of the Planck blackbody function for temperature <code>T</code> at wavelength <code>λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/synthesize.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.constant_R_LSF-Union{Tuple{F}, Tuple{AbstractVector{F}, Any, Any}} where F&lt;:AbstractFloat" href="#SSSynth.constant_R_LSF-Union{Tuple{F}, Tuple{AbstractVector{F}, Any, Any}} where F&lt;:AbstractFloat"><code>SSSynth.constant_R_LSF</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Applies a gaussian line spread function with constant spectral resolution, R = λ/Δλ.</p><p>This will have weird behavior if your wavelength grid is not locally linearly-spaced. It is intended to be run on a fine wavelength grid, then downsampled to the observational (or  otherwise desired) grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/LSF.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.get_absolute_abundances-Tuple{Any, Any, Dict}" href="#SSSynth.get_absolute_abundances-Tuple{Any, Any, Dict}"><code>SSSynth.get_absolute_abundances</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate N<em>X/N</em>total for each X in <code>elements</code> given some <code>specified_abundances</code>, A(X).  Use the  metallicity [X/H] to calculate those remaining from the solar values (except He).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/synthesize.jl#L94-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.get_atoms-Tuple{Any}" href="#SSSynth.get_atoms-Tuple{Any}"><code>SSSynth.get_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the atoms that make up a diatomic molecule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.get_mass-Tuple{Any}" href="#SSSynth.get_mass-Tuple{Any}"><code>SSSynth.get_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the mass of <code>atom_or_molecule</code> in g.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/atomic_data.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ismolecule-Tuple{Any}" href="#SSSynth.ismolecule-Tuple{Any}"><code>SSSynth.ismolecule</code></a> — <span class="docstring-category">Method</span></header><section><div><p>true if the string passed represents a molecule (with or without its ionization state)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.line_absorption-Tuple{Any, Any, Any, Dict, Dict, Dict, Dict, Any}" href="#SSSynth.line_absorption-Tuple{Any, Any, Any, Dict, Dict, Dict, Dict, Any}"><code>SSSynth.line_absorption</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">line_absorption(linelist, λs, temp, n_densities, atomic_masses, partition_fns, 
             ionization_energies; window_size)</code></pre><p>Calculate the opacity coefficient, α, in units of cm^-1 from all lines in <code>linelist</code>, at wavelengths <code>λs</code>. </p><p>other arguments:</p><ul><li><code>temp</code> the temerature in K</li><li><code>n_densities</code>, a Dict mapping species to absolute number density [cm^-3].</li><li><code>window_size</code> (optional, default: 20), the maximum distance from the line center at which line </li></ul><p>opacities should be calculated in included.</p><ul><li><code>ξ</code> is the microturbulent velocity in cm/s</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/line_opacity.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.line_profile-Union{Tuple{F}, Tuple{F, F, F, SSSynth.Line, AbstractVector{F}}} where F&lt;:AbstractFloat" href="#SSSynth.line_profile-Union{Tuple{F}, Tuple{F, F, F, SSSynth.Line, AbstractVector{F}}} where F&lt;:AbstractFloat"><code>SSSynth.line_profile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">line_profile(temp, atomic_mass, ξ, line, λs)</code></pre><p>The line profile, ϕ, at wavelengths <code>λs</code> in cm. <code>temp</code> should be in K, <code>atomic_mass</code> should be in g, microturbulent velocity, <code>ξ</code>, should be in  cm/s, <code>line</code> should be one of the entries returned by <code>read_line_list</code>. Note that this returns values in units of cm^-1, not Å^-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/line_opacity.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.molecular_equilibrium-NTuple{4, Any}" href="#SSSynth.molecular_equilibrium-NTuple{4, Any}"><code>SSSynth.molecular_equilibrium</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Iteratively solve for the number density of each species. Returns a Dict mapping species to number  densities.</p><p>arguments:</p><ul><li>the system of molecular equilibrium equations <code>MEQs</code> (the thing returned by </li></ul><p><code>molecular_equilibrium_equations</code>)</p><ul><li>the temperature <code>T</code>, </li><li>the number density of non-electron particles <code>nₜ</code></li><li>the electron number density <code>nₑ</code></li><li>a Dict of N<em>X/N</em>total, <code>absolute_abundances</code></li><li>a Dict of ionization energies, <code>ionization_energies</code></li><li>a Dict of partition functions, <code>partition_fns</code></li><li>a Dict of log molecular equilibrium constants, <code>equilibrium_constants</code>, in partial pressure form.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/statmech.jl#L150-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.molecular_equilibrium_equations-NTuple{4, Any}" href="#SSSynth.molecular_equilibrium_equations-NTuple{4, Any}"><code>SSSynth.molecular_equilibrium_equations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a NamedTuple representing the system of equations specifying molecular equilibrium.</p><p>arguments:</p><ul><li>A Dict of <code>absolute_abundances</code>, N<em>X/N</em>total</li><li>a Dict of ionization energies, <code>ionization_energies</code>.  The keys of <code>ionization_energies</code> act as a  list of all atoms.</li><li>a Dict of partition functions, <code>partition_fns</code></li><li>a Dict of log moleculare equilibrium constants, <code>equilibrium_constants</code>, in partial pressure form.  The keys of <code>equilibrium_constants</code> act as a list of all molecules.</li></ul><p>The system of equations is specified with the number densities of the neutral atoms as free  parameters.  Each equation specifies the conservation of a particular species, e.g. (simplified)</p><p>n(O) = n(CO) + n(OH) + n(O I) + n(O II) + n(O III).</p><p>In this equation:</p><ul><li>n(O), the number density of oxygen atoms in any form comes <code>absolute_abundances</code> and the total</li></ul><p>number density (supplied later)</p><ul><li>n(O I) is a free parameter.  The numerical solver is varying this to satisfy the system of  equations.</li><li>n(O II), and n(O III) come from the Saha (ionization) equation given n(O I)</li><li>n(CO) and n(OH) come from the molecular equilibrium constants K, which are precomputed  over a range of temperatures. </li></ul><p>K is defined in terms of partial pressures, so e.g. K(OH)  ==  (p(O) p(H)) / p(OH)  ==  (n(O) + n(H)) / n(OH) kT Alternatively, this could be computed via a Saha equation involving the molecular partition function and dissolution energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/statmech.jl#L73-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.parse_species_code-Tuple{AbstractString}" href="#SSSynth.parse_species_code-Tuple{AbstractString}"><code>SSSynth.parse_species_code</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_species_code(code)</code></pre><p>Parse the &quot;species code&quot; as it is often specified in line lists and return a the &quot;astronomy&quot;  notation. 01.00 → &quot;H<em>I&quot;, 02.01 → &quot;He</em>II&quot;, 02.1000 → &quot;He<em>II&quot;, 0608 → &quot;CO</em>I&quot;, etc.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.read_line_list-Tuple{String}" href="#SSSynth.read_line_list-Tuple{String}"><code>SSSynth.read_line_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_line_list(fname; format=&quot;kurucz&quot;)</code></pre><p>Parse the provided line list. in &quot;Kurucz&quot; format. Pass <code>format=&quot;kurucz&quot;</code> for a <a href="http://kurucz.harvard.edu/linelists.html">Kurucz line list</a>, <code>format=&quot;vald&quot;</code> for a Vald line list, and <code>format=&quot;moog&quot;</code> for a MOOG line list.</p><p>Note that dissociation energies in a MOOG line list will be ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.read_model_atmosphere-Tuple{AbstractString}" href="#SSSynth.read_model_atmosphere-Tuple{AbstractString}"><code>SSSynth.read_model_atmosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read_model_atmosphere(fname)</code></pre><p>Parse the provided model atmosphere file in  <a href="https://marcs.astro.uu.se/krz_format.html">&quot;Kurucz&quot; format</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/atmosphere.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.read_partition_funcs-Tuple{Any}" href="#SSSynth.read_partition_funcs-Tuple{Any}"><code>SSSynth.read_partition_funcs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">functon setup_atomic_partition_funcs()</code></pre><p>Constructs a Dict holding functions for various atomic species that computes the partition function at an input temperature.</p><p>In more detail, the partition function is linearly interpolated from values tabulated from Barklem  &amp; Collet (2016). The partition functions can only be evaluated at temperatures between 1e-5 K and  1e4 K. The tabulated values were NOT computed with a cutoff principle quantum number. This can lead to a couple percent error for some neutral species in solar type stars (I think the problem becomes worse in hotter stars). See the paper for more details.</p><p>Note that the paper seems to suggest that we could actually use cubic interpolation. That should be revisited in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/partition_func.jl#L31-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.saha_ion_weights-Tuple{Any, Any, String, Dict, Dict}" href="#SSSynth.saha_ion_weights-Tuple{Any, Any, String, Dict, Dict}"><code>SSSynth.saha_ion_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns <code>(wII, wIII)</code>, where <code>wII</code> is the ratio of singly ionized to neutral atoms of a given  element, and <code>wIII</code> is the ration of doubly ionized to neutral atoms.</p><p>arguments:</p><ul><li>temperature <code>T</code> [K]</li><li>electron number density <code>nₑ</code> [cm^-3]</li><li>atom, the atomic symbol of the element </li><li><code>ionization_energies</code> is a Dict mapping elements to their first three ionization energies</li><li><code>partition_funcs</code> is a Dict mapping species to their partition functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/statmech.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.saha_ion_weights-Tuple{Any, Any, Vector{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:AbstractFloat, Vector{Function}}" href="#SSSynth.saha_ion_weights-Tuple{Any, Any, Vector{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:AbstractFloat, Vector{Function}}"><code>SSSynth.saha_ion_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><p>convieience method for easier testing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/statmech.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.setup_equilibrium_constants-Tuple{}" href="#SSSynth.setup_equilibrium_constants-Tuple{}"><code>SSSynth.setup_equilibrium_constants</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a Dict holding the default (Barklem &amp; Collet 2016) log equilibrium constants.</p><p>There are two confusing things about equation 7 in this paper.  The first is that it defines K as  the reciprocal of what is actually supplied in the data table.  The second is that in order for it  to be correct, m must be interpreted as a reduced mass, m₁m₂/(m₁ + m₂).  This can be verified by  re-deriving the equilibrium constants from the partition functions and dissolution constants  provided by the paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/partition_func.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.setup_ionization_energies" href="#SSSynth.setup_ionization_energies"><code>SSSynth.setup_ionization_energies</code></a> — <span class="docstring-category">Function</span></header><section><div><p>setup<em>ionization</em>energies([filename])</p><p>Parses the table of ionization energies and returns it as a dictionary mapping elements to their ionization energies, <code>[χ₁, χ₂, χ₃]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/statmech.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.setup_partition_funcs" href="#SSSynth.setup_partition_funcs"><code>SSSynth.setup_partition_funcs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a Dict holding the default (Barklem &amp; Collet 2016) partition functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/partition_func.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.sigma_line-Union{Tuple{F}, Tuple{Any, Any}} where F&lt;:AbstractFloat" href="#SSSynth.sigma_line-Union{Tuple{F}, Tuple{Any, Any}} where F&lt;:AbstractFloat"><code>SSSynth.sigma_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sigma_line(wl, log_gf)</code></pre><p>The cross-section at wavelength <code>wl</code> in Ångstroms of a transition for which the product of the degeneracy and oscillator strength is <code>10^log_gf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/line_opacity.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.strip_ionization-Tuple{AbstractString}" href="#SSSynth.strip_ionization-Tuple{AbstractString}"><code>SSSynth.strip_ionization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get the chemical symbol for the element of the species</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/linelist.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.synthesize-Union{Tuple{F}, Tuple{Any, Any, AbstractVector{F}}} where F&lt;:AbstractFloat" href="#SSSynth.synthesize-Union{Tuple{F}, Tuple{Any, Any, AbstractVector{F}}} where F&lt;:AbstractFloat"><code>SSSynth.synthesize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">synthesize(atm, linelist, λs, [metallicity, [alpha]]; abundances=Dict())</code></pre><p>Solve the transfer equation in the model atmosphere <code>atm</code> with the transitions in <code>linelist</code> at the  wavelengths <code>λs</code> [Å] to get the resultant astrophysical flux at each wavelength.</p><p>optional arguments:</p><ul><li><code>metallicity</code>, i.e. [metals/H] is log_10 solar relative</li><li><code>vmic</code> (default: 0) is the microturbulent velocity, ξ, in km/s.</li><li><code>abundances</code> are A(X) format, i.e. A(x) = log<em>10(n</em>X/n<em>H), where n</em>X is the number density of X.</li><li><code>line_window</code> (default: 10): the farthest any line can be from the provide wavelenth range range  before it is discarded (in Å).</li><li><code>ionization_energies</code>, a Dict containing the first three ionization energies of each element,   defaults to <code>SSSynth.ionization_energies</code>.</li><li><code>partition_funcs</code>, a Dict mapping species to partition functions. Defaults to data from   Barklem &amp; Collet 2016, <code>SSSynth.partition_funcs</code>.</li><li><code>equilibrium_constants</code>, a Dict mapping diatomic molecules to theirmolecular equilbrium constants in partial pressure form.  Defaults to data from Barklem and Collet 2016,  <code>SSSynth.equilibrium_constants</code>.</li></ul><p>Uses solar abundances scaled by <code>metallicity</code> and for those not provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/synthesize.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.total_continuum_opacity-Union{Tuple{F}, Tuple{Vector{F}, F, F, F, Dict, Dict}} where F&lt;:AbstractFloat" href="#SSSynth.total_continuum_opacity-Union{Tuple{F}, Tuple{Vector{F}, F, F, F, Dict, Dict}} where F&lt;:AbstractFloat"><code>SSSynth.total_continuum_opacity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The total continuum opacity, κ, at many frequencies, ν.</p><ul><li><code>νs</code> are frequencies in Hz</li><li><code>T</code> is temperature in K</li><li><code>nₑ</code> is the electron number density in cm^-3</li><li><code>ρ</code> is the density in g cm^-3 </li><li><code>number_densities</code> is a <code>Dict</code> mapping each species to its number density</li><li><code>partition_funcs</code> is a `Dict mapping each species to its partition function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/synthesize.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.translational_U-Tuple{Any, Any}" href="#SSSynth.translational_U-Tuple{Any, Any}"><code>SSSynth.translational_U</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The contribution to the partition function from the free movement of a particle. Used in the Saha equation.</p><p>arguments</p><ul><li><code>m</code> is the particle mass</li><li><code>T</code> is the temperature in K</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/statmech.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.trapezoid_rule-Tuple{Any, Any}" href="#SSSynth.trapezoid_rule-Tuple{Any, Any}"><code>SSSynth.trapezoid_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoid_rule(xs, fs)</code></pre><p>Approximate the integral from x₁ to x₂ of f(x) with the trapezoid rule given x-values <code>xs</code> and f(x) values <code>fs</code>.</p><p>This should be good enough to numerically solve the transport equation, since model atmospheres usually have carefully chosen knots.  We probably want to add higher-order aproximations later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/synthesize.jl#L180-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.H2plus_bf_and_ff-NTuple{5, Float64}" href="#SSSynth.ContinuumOpacity.H2plus_bf_and_ff-NTuple{5, Float64}"><code>SSSynth.ContinuumOpacity.H2plus_bf_and_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H2plus_bf_and_ff(nH_I_div_partition, n_HII, ν, ρ, T)</code></pre><p>Compute the combined H₂⁺ bound-free and free-free opacity κ.</p><p>This uses polynomial fits from Gray (2005) that were derived from data tabulated in <a href="https://ui.adsabs.harvard.edu/abs/1952MNRAS.112...40B/abstract">Bates (1952)</a>.</p><p><strong>Arguments</strong></p><ul><li><code>nH_I_div_partition::Float64</code>: the total number density of H I divided by its partition   function.</li><li><code>nH_II::Float64</code>: the number density of H II (not of H₂⁺).</li><li><code>ν::Float64</code>: frequency in Hz</li><li><code>ρ::Float64</code>: mass density in g/cm³</li><li><code>T::Float64</code>: temperature in K</li></ul><p><strong>Notes</strong></p><p>This follows equation 8.15 of Gray (2005), which involves 2 polynomials that were fit to data provided in <a href="https://ui.adsabs.harvard.edu/abs/1952MNRAS.112...40B/abstract">Bates (1952)</a>.</p><p>The combined H₂⁺ bound-free and free-free opacity opacity calculation can be cast as:     κ = const * σ₁ * exp(-U₁ / (kboltz<em>T)) * n(H I, n=1) * n(H II) * (1 - exp(-hν/(kboltz</em>T))) / ρ where σ₁ and U₁ are just functions of ν. Note that Bates (1952) and Gray (2005) both use the number density of all energy states of H I instead of n(H I, n=1). However, Kurucz (1970) makes a note in section 5.2 about how the photodisociation of H₂⁺ produces a ground state H atom and that we should therefore use n(H I, n=1) instead. This difference will only cause Bates/Gray to be wrong by a fraction of a percent (at most) for T ≤ 1.2e4 K. In this function we use n(H I, n=1).</p><p>In this function, we use polynomial approximations that Gray (2005) fit for σ₁ and U₁ using data from Table 1 of Bates (1952). Gray (2005) notes that the approximations match Bates&#39; (1952) tabulated absorption data for 3800 Å ≤ λ ≤ 25000 Å at an accuracy of 0.3%. After reviewing the data in Bates (1952) I&#39;ve concluded that Gray (2005) actually rounded down the lower end of the wavelength from 10⁵/26 Å or ∼3847 Å. (In other words, the approximation is good for 3847 Å ≤ λ ≤ 25000.0 Å).</p><p>While this may fit to σ₁ and U₁ to better than 0.3%, comparisons against values from table 2 of Bates (1952) indicate that the function reproduces the full absorption coeffient at better than 1.5%. Gray (2005) did not provide a temperature range, but Bates (1952) only computed the absorption coefficient for 2500 K ≤ T ≤ 12000 K. In the text they have a comment that the proton&#39;s De Broglie wavelength is large at 2500 K and their semi-classical treatment may start to break down. However, as long as use n(H I, n=1), there doesn&#39;t seem to be any reason for us to enforce an upper Temperature limit.</p><p>Bates (1952) states that his classical treatment of the interaction is probably most accurate at higher temperatures and longer wavelengths (note that the longest λ considered in the paper is 8 times larger than the max λ the polynomials are fit against). He suggests that treatment is probably correct &quot;to well within one part in ten even at the lower temperatures and [lower wavelengths].&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/opacity_H.jl#L201-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.Heminus_ff-Union{Tuple{Flt}, NTuple{5, Flt}} where Flt&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.Heminus_ff-Union{Tuple{Flt}, NTuple{5, Flt}} where Flt&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.Heminus_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Heminus_ff(nHe_I_div_partition, ne, ν, ρ, T)</code></pre><p>Compute the He⁻ free-free opacity κ.</p><p>The naming scheme for free-free absorption is counter-inutitive. This actually refers to the reaction:  photon + e⁻ + He I -&gt; e⁻ + He I.</p><p><strong>Arguments</strong></p><ul><li><code>nHe_I_div_partition::Flt</code>: the total number density of H I divided by its partition function.</li><li><code>ne::Flt</code>: the number density of free electrons.</li><li><code>ν::Flt</code>: frequency in Hz</li><li><code>ρ::Flt</code>: mass density in g/cm³</li><li><code>T::Flt</code>: temperature in K</li></ul><p><strong>Notes</strong></p><p>This follows equation 8.16 of Grey (2005) which provides a polynomial fit absorption to data tabulated in <a href="https://ui.adsabs.harvard.edu/abs/1994MNRAS.269..871J/abstract">John 1994</a>. According to that equation the &quot;continuous absorption coefficient per Hydrogen&quot; is given by:     α(He⁻_ff)<em>Pₑ</em>A(He) / (1 + Φ(He)/Pₑ) in which</p><ul><li>log<em>10(α(He⁻</em>ff)) is the polynomial term.</li><li>A(He) is the number abundance of Helium particles relative to Hydrogen particles. For reference, A(He) = [n(He I) + n(He II) + n(He III)] / [n(H I) + n(H II)]</li><li>Pₑ is the partial pressure contributed by electrons. For reference, Pₑ = nₑ*kb * T.</li><li>1/(1 + Φ(He)/Pₑ) comes from the Saha equation and expresses n(He I) / [n(He I) + n(He II)].</li></ul><p>In the above expression, α(He⁻_ff)*Pₑ specifies the free-free atomic absorption coefficient per ground state He I atom. The expression seems to implicitly assume that</p><ul><li>approximately all He I is in the ground state</li><li>n(He I) / [n(He I) + n(He II)] is roughly n(He I) / [n(He I) + n(He II) + n(HeIII)]</li></ul><p>(at least for the range of temperatures where α can be accurately computed).</p><p>To convert the expression to opacity, they divided it by the product of the mean molecular weight and the Hydrogen mass. With that in mind, we can write an the equation for opacity (removing the apparent assumptions) as κ<em>ν = α(He⁻</em>ff)<em>Pₑ</em>n(He I, n=1)/ρ.</p><p>For 5063 Å ≤ λ ≤ 151878 Å and 2520 K ≤ T ≤ 10080 K, Gray (2005) claims that the polynomial fit the tabulated data at a precision of 1% or better. In practice, we found that it only fits the data to better than 3.1% (it&#39;s possible that for smaller λ the fit may be better). For reference, the tabulated data in these ranges of values consist of an irregularly spaced rectangular grid with 15 λ values and 9 Temperature values. According to John (1994), improved calculations are unlikely to alter the tabulated data for λ &gt; 1e4Å, &quot;by more than about 2%.&quot; The errors introduced by the approximations for 5.06e3 Å ≤ λ ≤ 1e4 Å &quot;are expected to be well below 10%.&quot;</p><p>An alternative approach using a fit to older data is provided in section 5.7 of Kurucz (1970).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/opacity_He.jl#L39-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.Hminus_bf-Union{Tuple{Flt}, NTuple{5, Flt}, NTuple{6, Flt}} where Flt&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.Hminus_bf-Union{Tuple{Flt}, NTuple{5, Flt}, NTuple{6, Flt}} where Flt&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.Hminus_bf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Hminus_bf(nH_I_div_partition, ne, ν, ρ, T, [ion_energy_H⁻])</code></pre><p>Compute the H⁻ bound-free opacity κ</p><p><strong>Arguments</strong></p><ul><li><code>nH_I_div_partition::Flt</code>: the total number density of H I divided by its partition function.</li><li><code>ne</code> the electron number density</li><li><code>ν::Flt</code>: frequency in Hz</li><li><code>ρ::Flt</code>: mass density in g/cm³</li><li><code>T::Flt</code>: temperature in K</li><li><code>ion_energy_H⁻::Flt</code>: Specifies the ionization energy of the single state of H⁻ in eV. This is  roughly 0.7552 eV.</li></ul><p><strong>Notes</strong></p><p>This function assumes that n(H⁻) ≪ n(H I) + n(H II). The number density of n(H⁻) should not be pre-computed (instead it&#39;s computed internally by this function).</p><p>This function is adapted from equation 8.12 from Grey (2005). This equation gives the absorption coefficient per H I atom (uncorrected by stimulated emission) is given by:     αff<em>H⁻ * 8.316e-10 * Pₑ * θ^2.5 * 10^(ion</em>energy_H⁻ * θ) * (U(H⁻,T)/ U(H I,T)) where:</p><ul><li>αff_H⁻ is the photo dissociation cross-section. This can estimated with equation 8.11.</li><li>θ = log10(e)/(k*T) or θ = 5040/T in units of eV⁻¹</li><li>U(H⁻,T) is the partition function of H⁻ at temperature T. This is always 1</li><li>U(H I,T) is the partition function of H I at temperature T. This is 2 at low to intermediate T.</li></ul><p>Eqn 8.12 of Grey (2005) implicitly assumes that (U(H⁻,T)/ U(H I,T)) is always equal to 0.5.</p><p>This expression is simplicitly a rewritten form of: αff_H⁻ * n(H⁻)/n(H I) where n(H⁻)/n(H I) has been replaced with the expanded form of the saha equation, in which n₀ = n(H⁻) and n₁ = n(H I).</p><p>Combining 8.18, and 8.19 of Gray (2005), indicate that the version opacity contribution of H⁻ bound-free absorption (with stimulated emission correction) is given by:                      n(H⁻)                                  n(H I)          n(H I) + n(H II)    κ<em>ν = α</em>bf(H⁻) * –––  * (1 - exp(-h<em>ν/(k</em>T))) * ––––––––– * ––––––––-                     n(H I)                             n(H I) + n(H II)            ρ This can be rewritten as: κ<em>ν = α</em>bf(H⁻) * n(H⁻) * (1 - exp(-h<em>ν/(k</em>T))) / ρ</p><p>This function uses the polynomial provided in equation 8.11 of Gray (2005), that fits the tabulated data from Wishart (1979). While Gray (2005) claims that the polynomial fits the data with 0.2% precision for 2250 Å ≤ λ ≤ 15000 Å, in practice we find that it fits the data to better than 0.25% precision. Wishart (1979) expects the tabulated data to have better than 1% percent accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/opacity_H.jl#L73-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.Hminus_ff-Union{Tuple{Flt}, NTuple{5, Flt}} where Flt&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.Hminus_ff-Union{Tuple{Flt}, NTuple{5, Flt}} where Flt&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.Hminus_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Hminus_ff(nH_I_div_partition, ne, ν, ρ, T)</code></pre><p>Compute the H⁻ free-free opacity κ</p><p>The naming scheme for free-free absorption is counter-inutitive. This actually refers to the  reaction:  photon + e⁻ + H I -&gt; e⁻ + H I.</p><p><strong>Arguments</strong></p><ul><li><code>nH_I_div_partition::Flt</code>: the total number density of H I divided by its partition function.</li><li><code>ne::Flt</code>: the number density of free electrons.</li><li><code>ν::Flt</code>: frequency in Hz</li><li><code>ρ::Flt</code>: mass density in g/cm³</li><li><code>T::Flt</code>: temperature in K</li></ul><p><strong>Notes</strong></p><p>This is taken from equation 8.13 of Gray (2005). This uses a polynomial to Bell &amp; Berrington (1987) tabulated values for α<em>ff(H⁻), which implicitly includes the correction for stimulated emission. The polynomial fits α</em>ff(H⁻) in the range 2520 K ≤ T ≤ 10080 K and 2604 Å ≤ λ ≤ 113918 Å. According to the book, the polynomial fit to the tabulated data typically has 1% precision. We find that at worst, the discrepancy never exceeds 2.25%.</p><p>From equations 8.13, 8.18, and 8.19 of Gray (2005), the free-free opacity from H⁻ is given by:                               n(H I)          n(H I) + n(H II)    κ<em>ν = α</em>ff(H⁻) * Pₑ * ––––––––– * ––––––––-                           n(H I) + n(H II)            ρ This can be rewritten as: κ<em>ν = α</em>ff(H⁻) * Pₑ * n(H I) / ρ</p><p>Based on Section 5.3 from Kurucz (1970), I&#39;m fairly confident that the &quot;more correct&quot; version of the opacity equation should actually read  κ<em>ν = α</em>ff(H⁻) * Pₑ * n(H I, n = 1) / ρ, and that the form provided by Gray (2005) implicitly assumes that n(H I, n = 1) ~ n(H I). This seems to be a  prettygood assumption given the tabulated values of the partition function in Table D.2 of Gray  (2005). From the boltzmann equation:      n(H I, n = 1) = n(H I)<em>gₙ₌₁/u(T)</em>exp(-Eₙ₌₁/(k<em>T)) = n(H I) * 2/u(T)</em>exp(0) = n(H I) * 2/u(T). According to Table D.2 of Grey, this approximation only introduces a ≤0.5% overestimate in  n(H I, n = 1) over the temperature range where the polynomial is valid.</p><p>We also considered the polynomial fit in Section 5.3 from Kurucz (1970). Unfortunately, it seems wrong (it gives lots of negative numbers).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/opacity_H.jl#L125-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity._Hminus_bf_cross_section-Tuple{AbstractFloat}" href="#SSSynth.ContinuumOpacity._Hminus_bf_cross_section-Tuple{AbstractFloat}"><code>SSSynth.ContinuumOpacity._Hminus_bf_cross_section</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_Hminus_bf_cross_section(ν)</code></pre><p>Compute the H⁻ bound-free cross-section, which has units of cm^2 per H⁻ particle.</p><p>The cross-section does not include a correction for stimulated emission.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/opacity_H.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity._hydrogenic_bf_high_n_opacity-Tuple{Integer, Integer, AbstractFloat, AbstractFloat, AbstractFloat, AbstractFloat, AbstractFloat}" href="#SSSynth.ContinuumOpacity._hydrogenic_bf_high_n_opacity-Tuple{Integer, Integer, AbstractFloat, AbstractFloat, AbstractFloat, AbstractFloat, AbstractFloat}"><code>SSSynth.ContinuumOpacity._hydrogenic_bf_high_n_opacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_hydrogenic_bf_high_n_opacity(Z, nmin, nsdens_div_partition, ν, T, ion_energy)</code></pre><p>Approximates the sum of opacity contributions by all bound-free transitions in which the electron originates in an energy level of nmin or larger using an integral.</p><p>In full detail, the calculated quantity is described as     ∑<em>{n&#39;=nmin}^∞ ndens(n=n&#39;) * α</em>ν(n=n&#39;) * (1 - exp(-hν/k/T))/ρ, where α(n=n&#39;) is the absorption coefficient for the bound-free atomic absorption coefficient (uncorrected for stimulated emission). This function approximates this sum with an integral.</p><p><strong>Arguments</strong></p><ul><li><code>Z::Integer</code>: Z is the atomic number of the ion (1 for HI)</li><li><code>nmin::Integer</code>: The lowest energy level (principle quantum number) included in the calculation</li><li><code>nsdens_div_partition::AbstractFloat</code> is the number density of the current species divided by the  partition function.</li><li><code>ν::Flt</code>: frequency in Hz</li><li><code>ρ::Flt</code>: mass density in g/cm³</li><li><code>T::Flt</code>: temperature in K</li><li><code>ion_energy::AbstractFloat</code>: the ionization energy from the ground state (in eV).</li></ul><p><strong>Notes</strong></p><p>This implements equation (5.6) from Kurucz (1970). I think ρ was simply omitted from that equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/hydrogenic_bf_ff.jl#L76-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity._ndens_Hminus" href="#SSSynth.ContinuumOpacity._ndens_Hminus"><code>SSSynth.ContinuumOpacity._ndens_Hminus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_ndens_Hminus(nH_I_div_partition, ne, T, ion_energy = _H⁻_ion_energy)</code></pre><p>Compute the number density of H⁻ (implements eqn 5.10 of Kurucz 1970). This is an application of the saha equation where the &quot;ground state&quot; is H⁻ and the &quot;first ionization state&quot; is H I. The partition function of H⁻ is 1 at all temperatures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/opacity_H.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.electron_scattering-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.electron_scattering-Union{Tuple{F}, Tuple{F, F}} where F&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.electron_scattering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">electron_scattering(nₑ, ρ)</code></pre><p>Compute the opacity from scattering off of free electrons. This has no wavelength dependence. It assumes isotropic scattering</p><p><strong>Arguments</strong></p><ul><li><code>nₑ::F</code>: number density of free electrons (in cgs)</li><li><code>ρ::F</code>: the mass density</li></ul><p><strong>Notes</strong></p><p>I adopted the formula described in section 5.12 of Kurucz (1970) and the equation in the electron scattering subsection of Gray (2005); the actual coefficient value comes from the latter. It turns out that the coefficient in Kurucz (1970) has a typo (it&#39;s a factor of 10 too large).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/continuum_opacity.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.gaunt_ff_kurucz-Tuple{Any, Any}" href="#SSSynth.ContinuumOpacity.gaunt_ff_kurucz-Tuple{Any, Any}"><code>SSSynth.ContinuumOpacity.gaunt_ff_kurucz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gaunt_ff_kurucz(log_u, log_γ2)</code></pre><p>computes the thermally averaged free-free gaunt factor by interpolating the table provided in section 5.1 of Kurucz (1970). The table was derived from a figure in Karsas and Latter (1961).</p><p><strong>Arguments</strong></p><ul><li><code>log_u::F</code>: Equal to log₁₀(u) = log₁₀(h<em>ν/(k</em>T))</li><li><code>log_γ2::F</code>: Equal to log₁₀(γ²) = log₁₀(RydbergH<em>Z²/(k</em>T))</li></ul><p><strong>Note</strong></p><p>There is some ambiguity over whether we should replace RydbergH*Z² in the definition of γ² with the ionization energy, but it&#39;s probably a negligible difference (given the log scale).</p><p>In the future, we may want to the interpolate the table reported in van Hoof, Ferland, Williams, Volk, Chatzikos, Lykins, &amp; Porter (2013) because it&#39;s more accurate and applies over a larger range of values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/hydrogenic_bf_ff.jl#L216-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.hydrogenic_bf_opacity-Union{Tuple{Flt}, Tuple{Integer, Flt, Flt, Flt, Flt, Flt, Integer}, Tuple{Integer, Flt, Flt, Flt, Flt, Flt, Integer, Bool}} where Flt&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.hydrogenic_bf_opacity-Union{Tuple{Flt}, Tuple{Integer, Flt, Flt, Flt, Flt, Flt, Integer}, Tuple{Integer, Flt, Flt, Flt, Flt, Flt, Integer, Bool}} where Flt&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.hydrogenic_bf_opacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hydrogenic_bf_opacity(Z, nmax_explicit_sum, nsdens_div_partition, ν, ρ, T,
                      ion_energy, [integrate_high_n])</code></pre><p>Compute the bound-free opacity contributed by all energy states of a Hydrogenic species</p><p>The calculation is broken into 2 parts: (i) the contributions of the lowest energy states are  explicitly summed and (ii) the contributions of the higher energy states are estimated with an  integral.</p><p><strong>Arguments</strong></p><ul><li><code>Z::Integer</code>: Z is the atomic number of the species (e.g. 1 for H I or 2 for He II)</li><li><code>nsdens_div_partition::Flt</code> is the total number density of the species divided by the species&#39;s  partition function.</li><li><code>ν::Flt</code>: frequency in Hz</li><li><code>ρ::Flt</code>: mass density in g/cm³</li><li><code>T::Flt</code>: temperature in K</li><li><code>ion_energy::AbstractFloat</code>: the ionization energy from the ground state (in eV). This can be   estimated as Z²*Rydberg<em>H (Rydberg</em>H is the ionization energy of Hydrogen)</li><li><code>nmax_explicit_sum::Integer</code>: The highest energy level whose opacity contribution is included in  the explicit sum. The contributions from higher levels are included in the integral.</li><li><code>integrate_high_n::bool</code>: When this is <code>false</code>, bf opacity from higher energy states are not  estimated at all. Default is <code>true</code>.</li></ul><p><strong>Notes</strong></p><p>This follows the approach described in section 5.1 of Kurucz (1970).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/hydrogenic_bf_ff.jl#L139-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.hydrogenic_ff_opacity-Union{Tuple{Flt}, Tuple{Integer, Flt, Flt, Flt, Flt, Flt}} where Flt&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.hydrogenic_ff_opacity-Union{Tuple{Flt}, Tuple{Integer, Flt, Flt, Flt, Flt, Flt}} where Flt&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.hydrogenic_ff_opacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hydrogenic_ff_opacity(Z, ni, ne, ν, ρ, T)</code></pre><p>computes the free-free opacity for a hydrogenic species</p><p>The naming convention for free-free absorption is counter-intuitive. A free-free interaction is named as though the species interacting with the free electron had one more bound electron (in  other words it&#39;s named as though the free-electron and ion were bound together). In practice, this means that <code>ni</code> should refer to:</p><ul><li>the number density of H II if computing the H I free-free opacity</li><li>the number density of He III if computing the He II free-free opacity</li><li>the number density of Li IV if computing the Li III free-free opacity</li></ul><p><strong>Arguments</strong></p><ul><li><code>Z::Integer</code>: the charge of the ion. For example, this is 1 for ionized H.</li><li><code>ni::Flt</code>: the number density of the ion species in cm⁻³.</li><li><code>ne::Flt</code>: the number density of free electrons.</li><li><code>ν::Flt</code>: frequency in Hz</li><li><code>ρ::Flt</code>: mass density in g/cm³</li><li><code>T::Flt</code>: temperature in K</li></ul><p><strong>Note</strong></p><p>This approach was adopted from equation 5.8 from section 5.1 of Kurucz (1970). Comparison against equation 5.18b of Rybicki &amp; Lightman (2004), reveals that the equation in Kurucz (1970) omits the dependence on ρ. According to Rybicki &amp; Lightman (2004) the free-free opacity (corrected for stimulated emission) is:     coef * Z² <em>ne * ni * (1 - exp(-hplanck</em>ν/(kboltz*T))) * g<em>ff / (sqrt(T) * ν³ * ρ) Note that the g</em>ff is the free-free gaunt factor and coef is ∼3.7e8 (a more exact coefficient can be computed from eqn 5.18a).</p><p>With this in mind, equation 5.8 of Kurucz (1970) should actually read     ne * n(H II) * F<em>ν(T) * (1 - exp(-hplanck<em>ν/(kboltz</em>T))) / ρ where F</em>ν(T) = coef * Z² * g_ff / (sqrt(T) * ν³).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/hydrogenic_bf_ff.jl#L237-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSSynth.ContinuumOpacity.ndens_state_hydrogenic-Union{Tuple{Flt}, Tuple{Integer, Flt, Flt, Flt}} where Flt&lt;:AbstractFloat" href="#SSSynth.ContinuumOpacity.ndens_state_hydrogenic-Union{Tuple{Flt}, Tuple{Integer, Flt, Flt, Flt}} where Flt&lt;:AbstractFloat"><code>SSSynth.ContinuumOpacity.ndens_state_hydrogenic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndens_state_hydrogenic(n, nsdens_div_partition, ion_energy, T)</code></pre><p>Calculates the LTE number density (in cm^-3) of a hydrogenic species at a given energy level.</p><p><strong>Arguments</strong></p><ul><li><code>n::Integer</code>: The quantum number of the state</li><li><code>nsdens_div_partition::Flt</code>: The total (including all states) number density of the current </li></ul><p>ionization species (in cm^-3) divided by the species&#39;s partition function.</p><ul><li><code>ion_energy::Flt</code>: The minimum energy (in eV) required to ionize the species (from the ground </li></ul><p>state). This can be estimated as Z²<em>ion_energy of hydrogen or Z²</em>Rydberg_H.</p><ul><li><code>T::Flt</code>: Temperature</li></ul><p><strong>Note</strong></p><p>This assumes that all hydrogenic species have a statistical weight of gₙ = 2*n².</p><p>This was taken from equation (5.4) of Kurucz (1970) (although this comes directly from the  boltzmann equation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ajwheeler/SSSynth.jl/blob/8c61303c13d62e92ac32fa52b7add464a1e5cb4d/src/continuum_opacity/hydrogenic_bf_ff.jl#L5-L23">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Quickstart</a><a class="docs-footer-nextpage" href="../refs/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 26 April 2021 16:46">Monday 26 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
